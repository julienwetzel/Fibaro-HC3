{"name":"Swisscom Box","type":"com.fibaro.genericDevice","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_1015"},"sections":{"items":[{"components":[{"components":[{"name":"setWifi_true","style":{"weight":"0.50"},"text":"WLAN On","type":"button","visible":true},{"name":"setWifi_false","style":{"weight":"0.50"},"text":"WLAN Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setGuestWifi_true","style":{"weight":"0.50"},"text":"Guest WLAN On","type":"button","visible":true},{"name":"setGuestWifi_false","style":{"weight":"0.50"},"text":"Guest WLAN Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setCentralStorage_true","style":{"weight":"0.50"},"text":"Central storage On","type":"button","visible":true},{"name":"setCentralStorage_false","style":{"weight":"0.50"},"text":"Central storage Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setHomeApp_true","style":{"weight":"0.50"},"text":"Home App On","type":"button","visible":true},{"name":"setHomeApp_false","style":{"weight":"0.50"},"text":"Home App Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setInternetMobileConnect_true","style":{"weight":"0.50"},"text":"Internet Mobile On","type":"button","visible":true},{"name":"setInternetMobileConnect_false","style":{"weight":"0.50"},"text":"Internet Mobile Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setDynDNS_true","style":{"weight":"0.50"},"text":"DynDNS On","type":"button","visible":true},{"name":"setDynDNS_false","style":{"weight":"0.50"},"text":"DynDNS Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"setVPNServer_true","style":{"weight":"0.50"},"text":"VPN On","type":"button","visible":true},{"name":"setVPNServer_false","style":{"weight":"0.50"},"text":"VPN Off","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"reboot_true","style":{"weight":"1.2"},"text":"Reboot Internet Box","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"refresh_true","style":{"weight":"1.2"},"text":"Refresh","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label1","style":{"weight":"1.2"},"text":"","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_1015"}}},"uiCallbacks":[{"callback":"actionButtonPressed","eventType":"onReleased","name":"setWifi_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setWifi_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setGuestWifi_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setGuestWifi_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setCentralStorage_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setCentralStorage_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setHomeApp_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setHomeApp_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setInternetMobileConnect_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setInternetMobileConnect_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setDynDNS_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setDynDNS_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setVPNServer_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"setVPNServer_false"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"reboot_true"},{"callback":"actionButtonPressed","eventType":"onReleased","name":"refresh_true"}],"quickAppVariables":[{"name":"Username","value":"admin"},{"name":"Password","value":"passwd"},{"name":"Url","value":"http://192.168.1.1"},{"name":"Model","value":"RTV1905VW"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"--[[\n   Copyright [2021] [Julien Wetzel]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n]]\n\nfunction QuickApp:onInit()\n    self.boolean = \"\"\n    self.boxInfo = {}\n\tself.config = Config:new(self)\n    self.model = self.config:getModel()\n    self:control()\n\tself.auth = Auth:new(self)\nend\n\nfunction QuickApp:control()\n    local devices = {\"RTV1905VW\"}\n    if not search(devices,self.model) then\n        self:error(\"Device model not exist, please change model in the variable.\")\n        self:error(\"----------------------\")\n        self:error(\"Model supported :\")\n        for _,v in pairs(devices) do self:error(v) end\n        self:error(\"----------------------\")\n    end\nend\n\nfunction QuickApp:actionButtonPressed(param)\n    self:updateView(\"refresh_true\", \"text\", \"LOADING...\")\n    local command = param.elementName\n    local btn,cmd = {},{}\n    for w in command:gmatch(\"%w+\") do table.insert(btn, w) end\n    cmd.method = btn[1]\n    cmd.command = btn[2]\n    self.auth:login(cmd)\nend\n\nfunction QuickApp:displayInfo()\n    cmd(\"displayInfo()\")\n    local txt = \"\"\n    function msg(t) txt = txt .. \"\\n\" .. t end \n\n\tlocal data = self.boxInfo\n    --print(jdump(json.encode(data))) \n    msg(os.date(\"Last update : %x %X \\n---------------------------------------------\"))\n    if isEmpty(data) then txt = \"Error\"\n    else\n        if data.wifi.data.Enable then msg(\"WLAN : On\") \n        else msg(\"WLAN : Off\")\n        end\n        if data.wifiguest.data.Enable then msg(\"Guest WLAN : On\")\n        else msg(\"Guest WLAN : Off\")\n        end\n        if data.centralstorage.status then msg(\"Central storage : On\")\n        else msg(\"Central storage : Off\")\n        end\n        if data.homeapp.status then msg(\"Home App : On\")\n        else msg(\"Home App : Off\")\n        end\n        if data.wwan.status.EnableTethering then msg(\"Internet Mobile : On\")\n        else msg(\"Internet Mobile : Off\")\n        end\n        if json.decode(data.dyndns.status).result then msg(\"DynDNS : On\")\n        else msg(\"DynDNS : Off\")\n        end\n        if data.vpn.data.config.Server[1].Enable then msg(\"VPN : On\")\n        else msg(\"VPN : Off\")\n        end\n        msg(\"---------------------------------------------\\nAdvanced Info\\n---------------------------------------------\")\n        msg(\"Internet Connection : \" .. data.controller.status.Connection)\n        msg(\"External IP : \" .. data.wan.data.IPAddress)\n        msg(\"Software version : \" .. data.device.status.SoftwareVersion)\n    end\n    self:updateView(\"label1\", \"text\", txt)\n    self:debug(txt)\n    self:updateView(\"refresh_true\", \"text\", \"Refresh\")\nend\n\nfunction QuickApp:setBoxInfo(t) self.boxInfo = TableConcat(self.boxInfo,t) end"},{"name":"HTTPClient","isMain":false,"isOpen":true,"content":"--[[\r\nHTTPClient wrapper\r\n@author ikubicki\r\n\r\nMIT License\r\n\r\nCopyright (c) 2020 Irek Kubicki\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n]]\r\n    \r\nclass 'HTTPClient'\r\n\r\nfunction HTTPClient:new(options)\r\n    if not options then\r\n        options = {}\r\n    end\r\n    self.options = options\r\n    return self\r\nend\r\n\r\nfunction HTTPClient:get(url, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'GET', nil, headers)) \r\nend\r\n\r\nfunction HTTPClient:post(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'POST', data, headers)) \r\nend\r\n\r\nfunction HTTPClient:postForm(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    headers[\"Content-Type\"] = 'application/x-www-form-urlencoded;charset=UTF-8'\r\n    client:request(self:url(url), self:requestOptions(success, error, 'POST', data, headers, true)) \r\nend\r\n\r\nfunction HTTPClient:put(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    client:request(self:url(url), self:requestOptions(success, error, 'PUT', data, headers)) \r\nend\r\n\r\nfunction HTTPClient:delete(url, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'DELETE', nil, headers)) \r\nend\r\n\r\nfunction HTTPClient:url(url)\r\n    if (string.sub(url, 0, 4) == 'http') then\r\n        return url\r\n    end\r\n    if not self.options.baseUrl then\r\n        self.options.baseUrl = 'http://localhost'\r\n    end\r\n    return self.options.baseUrl .. tostring(url)\r\nend\r\n\r\nfunction HTTPClient:requestOptions(success, error, method, data, headers, isFormData)\r\n    if error == nil then\r\n        error = function (error)\r\n            QuickApp:error(json.encode(error))\r\n        end\r\n    end\r\n    if method == nil then\r\n        method = 'GET'\r\n    end\r\n    local options = {\r\n        checkCertificate = false,\r\n        method = method,\r\n        headers = headers,\r\n    }\r\n    if data ~= nil then\r\n        if isFormData then\r\n            options.data = ''\r\n            for key, value in pairs(data) do\r\n                if string.len(options.data) > 0 then \r\n                    options.data = options.data .. '&'\r\n                end\r\n                options.data = options.data .. key .. '=' .. value\r\n            end\r\n        else\r\n            options.data = json.encode(data)\r\n        end\r\n    end\r\n    return {\r\n        options = options,\r\n        success = success,\r\n        error = error\r\n    }\r\nend"},{"name":"Auth","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nclass 'Auth'\r\n\r\nfunction Auth:new(app)\r\n    self.config = app.config\r\n    self.model = app.model\r\n    self.http = HTTPClient:new({\r\n        baseUrl = Config:getUrl()\r\n    })\r\n    self.RTV1905VW = RTV1905VW:new(app)\r\n\tself:init()  \r\n\treturn self\r\nend\r\n\r\nfunction Auth:login(info)\r\n    cmd(\"Auth:login()\")\r\n\tlocal url = '/ws'\r\n\tlocal callback = function(r)\r\n        --print(jdump(json.encode(r)))\r\n        local data = json.decode(r.data)\r\n        local contextID = data.data.contextID\r\n        local cookie = r.headers[\"Set-Cookie\"]\r\n\t\tif r.status == 200 then \r\n            self:setCookie(cookie)\r\n            self:setContextID(contextID)\r\n            if info.method == \"refresh\" then \r\n                self[self.model]:getInfo()\r\n            else\r\n                self[self.model].command = info.command\r\n                self[self.model][info.method](self[self.model])\r\n            end\r\n        else badNew(\"Auth:login\", r.status)\r\n\t\tend\r\n\tend\r\n\r\n\tself.http:post(url, self[self.model][\"getLoginBody\"](), callback, error, self:getHeaders({}))\r\n\treturn {}\r\nend\r\n\r\nfunction Auth:getHeaders(headers)\r\n\theaders = {\r\n        [\"Content-Type\"] = \"application/x-sah-ws-4-call+json\",\r\n        [\"Accept\"] = \"*/*\",\r\n        [\"Authorization\"] = \"X-Sah-Login\",\r\n    }\r\n\treturn headers\r\nend\r\n\r\nfunction Auth:getContextID() return self.contextID end\r\nfunction Auth:setContextID(v) self.contextID = v end\r\nfunction Auth:getCookie() return self.cookie end\r\nfunction Auth:setCookie(v) self.cookie = v end\r\nfunction Auth:resetAuth() self.contextID, self.cookie = \"\", \"\" end\r\n\r\nfunction Auth:init()\r\n    self.contextID = \"\"\r\n    self.cookie = \"\"\r\n    self.info = \"\"\r\n    self.model = Config:getModel()\r\nend"},{"name":"Tools","isMain":false,"isOpen":false,"content":"function printTable( t )\r\n\tlocal printTable_cache = {}\r\n\tlocal function sub_printTable( t, indent )\r\n\r\n\t\tif ( printTable_cache[tostring(t)] ) then\r\n\t\t\tprint( indent .. \"*\" .. tostring(t) )\r\n\t\telse\r\n\t\t\tprintTable_cache[tostring(t)] = true\r\n\t\t\tif ( type( t ) == \"table\" ) then\r\n\t\t\t\tfor pos,val in pairs( t ) do\r\n\t\t\t\t\tif ( type(val) == \"table\" ) then\r\n\t\t\t\t\t\tprint( indent .. \"[\" .. pos .. \"] => \" .. tostring( t ).. \" {\" )\r\n\t\t\t\t\t\tsub_printTable( val, indent .. string.rep( \" \", string.len(pos)+8 ) )\r\n\t\t\t\t\t\tprint( indent .. string.rep( \" \", string.len(pos)+6 ) .. \"}\" )\r\n\t\t\t\t\telseif ( type(val) == \"string\" ) then\r\n\t\t\t\t\t\tprint( indent .. \"[\" .. pos .. '] => \"' .. val .. '\"' )\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tprint( indent .. \"[\" .. pos .. \"] => \" .. tostring(val) )\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\telse\r\n\t\t\t\tprint( indent..tostring(t) )\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\tif ( type(t) == \"table\" ) then\r\n\t\tprint( tostring(t) .. \" {\" )\r\n\t\tsub_printTable( t, \"  \" )\r\n\t\tprint( \"}\" )\r\n\telse\r\n\t\tsub_printTable( t, \"  \" )\r\n\tend\r\nend\r\n\r\n--[[\r\nA simple function for printing a json string in a readble format\r\nThe function takes a json string as input and returns a formatted HTML string which can be printed using fibaro:dbug()\r\n\r\nBy Per Jarnehamamr, 2019\r\n\r\n--]]\r\n\r\nfunction jdump(jstr, indent) \r\n\tif not indent then indent = 2 end\r\n\r\n\tlocal str = \"<pre><font color=yellowgreen><br>\";\r\n\tlocal curr_ind = 0;\r\n\tlocal space = \"&nbsp\";\r\n\tlocal quotes = false; \r\n\r\n\tfor i = 1, string.len(jstr)  do\r\n\t\tchar = string.sub(jstr,i,i);\r\n\r\n\t\tif  char == '\"' then quotes = not quotes end\r\n\r\n\t\tif (char == \"{\") or (char == \"[\") then \r\n\t\t\tcurr_ind = curr_ind + indent;\r\n\t\t\tstr = str..char..\"<br>\"..string.rep(space,curr_ind);\r\n\r\n\t\telseif (char == \"}\") or (char == \"]\") then\r\n\t\t\tcurr_ind = curr_ind - indent;\r\n\t\t\tstr = str..\"<br>\"..string.rep(space,curr_ind)..char;\r\n\r\n\t\telseif char == \",\" then\r\n\t\t\tstr = str..char..\"<br>\"..string.rep(space,curr_ind);\r\n\r\n\t\telseif char == \":\" then\r\n\t\t\tif quotes then \r\n\t\t\t\tstr = str..char;\r\n\t\t\telse\r\n\t\t\t\tstr = str..space..char..space;\r\n\t\t\tend\r\n\r\n\t\telse\r\n\t\t\tstr = str..char;\r\n\t\tend\r\n\tend\r\n\r\n\treturn str..\"</font></pre>\";\r\nend\r\n\r\nfunction has_value (tab, val) --Fonction qui retourne true si la valeur est trouvée dans la table \r\n\tfor _,v in ipairs(tab) do\r\n\t\tfor _,k in pairs(v) do\r\n\t\t\tif k == val then\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\t\tif v == val then\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\treturn false\r\nend\r\n"},{"name":"Config","isMain":false,"isOpen":true,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nclass 'Config'\r\n\r\nfunction Config:new(app)\r\n    self.app = app\r\n    self:init()\r\n    return self\r\nend\r\n\r\nfunction Config:getUsername()\r\n    return self.username\r\nend\r\n\r\nfunction Config:getPassword()\r\n    return self.password\r\nend\r\n\r\nfunction Config:getUrl()\r\n    return self.url\r\nend\r\n\r\nfunction Config:getModel()\r\n    return self.model\r\nend\r\n\r\nfunction Config:init()\r\n    self.username = self.app:getVariable('Username')\r\n    self.password = self.app:getVariable('Password')\r\n    self.url = self.app:getVariable('Url')\r\n    self.model = self.app:getVariable('Model')\r\nend"},{"name":"RTV1905VW","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nclass 'RTV1905VW'\r\n\r\nfunction RTV1905VW:new(app)\r\n    self.quickapp = app\r\n    return self\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:getLoginBody()\r\n\tlocal body = {\r\n\t\tservice = \"sah.Device.Information\",\r\n\t\tmethod = \"createContext\",\r\n\t\tparameters = {\r\n\t\t\tapplicationName = \"webui\",\r\n\t\t\tusername = Config:getUsername(),\r\n\t\t\tpassword = Config:getPassword()\r\n\t\t}\r\n\t}\r\n\treturn body\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:reboot()\r\n\tcmd(\"RTV1905VW:reboot()\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setDynDNS(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/sysbus/NMC:reboot\"\r\n\t\tlocal body = {parameters = {reason = \"Webui reboot\"}}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:reboot()\", r.status)\r\n\t\t\tend\r\n\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setVPNServer()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setVPNServer(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setDynDNS(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/sysbus/VPN:setServer\"\r\n\t\tlocal body = {\r\n                    parameters = {\r\n                        server = \"default\",\r\n                        enable = boolean}}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setVPNServer()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setDynDNS()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setDynDNS(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setDynDNS(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/ws\"\r\n\t\tlocal body = {\r\n                        service = \"com.swisscom.apsm/dyndns.com.swisscom.apsm.dyndns\",\r\n                        method = \"Configure\",\r\n                        parameters = {enable = boolean}\r\n                        }\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setDynDNS()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setInternetMobileConnect()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setInternetMobileConnect(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setHomeApp(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/sysbus/NMC/WWAN:set\"\r\n\t\tlocal body = {parameters = {EnableTethering = boolean}}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setInternetMobileConnect()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n        \r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setHomeApp()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setHomeApp(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setHomeApp(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/ws\"\r\n\t\tlocal body = {\r\n                        service = \"com.vestiacom.rnas/com/vestiacom/rnas.com.vestiacom.rnas\",\r\n                        method = \"SetEnabled\",\r\n                        parameters = {\r\n                            enable = boolean\r\n                        }\r\n                        }\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setHomeApp()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setCentralStorage()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setCentralStorage(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setHomeApp(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/ws\"\r\n\t\tlocal body = {\r\n                        service = \"com.swisscom.stargate/ws/centralstorage.com.swisscom.stargate.centralstorage\",\r\n                        method = \"SetState\",\r\n                        parameters = {\r\n                            state = boolean\r\n                        }}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\t--print(jdump(json.encode(r)))\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setCentralStorage()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n        --print(jdump(json.encode(self:getHeaders({}))))\r\n        --print(jdump(json.encode(body)))\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setGuestWifi()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setGuestWifi(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setGuestWifi(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/sysbus/NMC/Guest:set\"\r\n\t\tlocal body = {\r\n\t\t\tparameters = {\r\n\t\t\t\tEnable = boolean\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setGuestWifi()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:setWifi()\r\n    boolean = toboolean(self.command)\r\n\tcmd(\"RTV1905VW:setWifi(\" .. tostring(boolean) .. \")\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:setWifi(boolean) end)\r\n\telse\r\n\t\tlocal url = \"/sysbus/NMC/Wifi:set\"\r\n\t\tlocal body = {\r\n\t\t\tparameters = {\r\n\t\t\t\tEnable = boolean,\r\n\t\t\t\tConfigurationMode = true,\r\n\t\t\t\tStatus = boolean\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlocal callback = function(r)\r\n\t\t\tif r.status == 200 then self:getInfo()\r\n\t\t\telse badNew(\"RTV1905VW:setWifi()\", r.status)\r\n\t\t\tend\r\n\t\t\tAuth:resetAuth()\r\n\t\tend\r\n\r\n\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({}))  \r\n\t\treturn {}\r\n\tend\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:getHeaders(headers)\r\n\t--cmd(\"RTV1905VW:getHeaders()\")\r\n\tlocal contextID = Auth:getContextID()\r\n    local cookies = Auth:getCookie()\r\n\r\n    local _, _, deviceID, sessionID, reste = string.find(cookies, \"(%w+)(.-);%s(.+)\")\r\n\r\n\tif isEmpty(contextID) then badNew(\"RTV1905VW:getHeaders()\", 800) end\r\n\theaders = {\r\n\t\t[\"Content-Type\"] = \"application/x-sah-ws-4-call+json\",\r\n\t\t[\"Accept\"] = \"*/*\",\r\n        --[\"Cookie\"] = Auth:getCookie(), \r\n\t\t[\"Cookie\"] = deviceID .. \"accept-language=fr-CH,fr; test=test; \" .. deviceID .. sessionID .. \"; swc/deviceID=\" .. deviceID .. \"; \" .. deviceID .. \"/context=\" .. contextID,\r\n\t\t[\"Authorization\"] = \"X-Sah \" .. Auth:getContextID(),\r\n        [\"X-Context\"] = contextID,\r\n        [\"X-Requested-With\"] = \"XMLHttpRequest\",\r\n        [\"User-Agent\"] = \"Fibaro/HC3\",\r\n        [\"Origin\"] = \"http://192.168.1.1\",\r\n        [\"Referer\"] = \"http://192.168.1.1\",\r\n        [\"Host\"] = \"192.168.1.1\",\r\n        [\"Connection\"] = \"keep-alive\",\r\n        [\"Accept-Encoding\"] = \"gzip, deflate\",\r\n        [\"Accept-Language\"] = \"fr-CH,fr;q=0.9\"\r\n\t}\r\n    \r\n    local headersContent = json.encode(headers)  \r\n    headers[\"Content-Length\"] = tostring(#headersContent)\r\n\treturn headers\r\nend\r\n-----------------------------------------------------------------------------\r\nfunction RTV1905VW:getInfo()\r\n\tcmd(\"RTV1905VW:getInfo()\")\r\n\tif isEmpty(Auth:getContextID()) then\r\n\t\tAuth:login(function() self:getInfo() end)\r\n\telse\r\n\t\tlocal urls = {}\r\n\t\turls = {\r\n\t\t\t[1] = {title = \"time\", url = \"/sysbus/Time:getTime\"},\r\n\t\t\t[2] = {title = \"lan\", url = \"/sysbus/APController/LAN:get\"},\r\n\t\t\t[3] = {title = \"wan\", url = \"/sysbus/NMC:getWANStatus\"},\r\n\t\t\t[4] = {title = \"controller\", url = \"/sysbus/APController:get\"},\r\n\t\t\t[5] = {title = \"wifi\", url = \"/sysbus/NMC/Wifi:get\"},\r\n\t\t\t[6] = {title = \"device\", url = \"/sysbus/DeviceInfo:get\"},\r\n\t\t\t[7] = {title = \"wifiguest\", url = \"/sysbus/NMC/Guest:get\"},\r\n            [8] = {title = \"wwan\", url = \"/sysbus/NMC/WWAN:get\"},\r\n            [9] = {title = \"vpn\", url = \"/sysbus/VPN:getServersConfig\"},\r\n            [10] = {title = \"homeapp\", url = \"/ws\", body = {\r\n                        service = \"com.vestiacom.rnas/com/vestiacom/rnas.com.vestiacom.rnas\",\r\n                        method = \"GetEnabled\",\r\n                        parameters = { }}},\r\n            [11] = {title = \"dyndns\", url = \"/ws\", body = {\r\n                        service = \"com.swisscom.apsm/dyndns.com.swisscom.apsm.dyndns\",\r\n                        method = \"IsEnabled\",\r\n                        parameters = { }}},\r\n            [12] = {title = \"centralstorage\", url = \"/ws\", body = {\r\n                        service = \"com.swisscom.stargate/ws/centralstorage.com.swisscom.stargate.centralstorage\",\r\n                        method = \"GetState\",\r\n                        parameters = { }}}\r\n\t\t}\r\n\t\t--Lien traduction fr : http://192.168.1.1/static/translations/stargatev2/fr.json\r\n\t\t--lien traduction de : http://192.168.1.1/static/translations/stargatev2/de.json\r\n\t\t--lien traduction it : http://192.168.1.1/static/translations/stargatev2/it.json \r\n\r\n\t\tlocal data = {}\r\n\t\tlocal t = {}\r\n\t\tlocal num = 0\r\n\t\tfor i=1, #urls do\r\n\t\t\tlocal callback = function(r)\r\n                --print(jdump(json.encode(r)))\r\n\t\t\t\tdata = json.decode(r.data)\r\n                --print(data)\r\n\t\t\t\tif r.status == 200 then\r\n\t\t\t\t\tt = {}\r\n\t\t\t\t\tif isEmpty(data) then t[urls[i].title] = {}\r\n\t\t\t\t\telse t[urls[i].title] = data\r\n\t\t\t\t\tend\r\n\r\n\t\t\t\t\tself.quickapp:setBoxInfo(t)\r\n\t\t\t\t\tnum = num + 1\r\n\r\n\t\t\t\t\tif num == #urls then self.quickapp:displayInfo() end\r\n\t\t\t\telse badNew(\"RTV1905VW:getInfo() title: \" .. urls[i].title, r.status)\r\n\t\t\t\tend\r\n\t\t\t\tAuth:resetAuth()\r\n\t\t\tend\r\n\r\n\t\t\turl = urls[i].url\r\n            body = urls[i].body\r\n            --print(jdump(json.encode(self:getHeaders({}))))\r\n\t\t\tHTTPClient:post(url, body, callback, error, self:getHeaders({})) \r\n\t\tend\r\n\t\treturn {}\r\n\tend\r\nend\r\n"},{"name":"Utilities","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nfunction isEmpty(s) return s == nil or s == \"\" end\r\nfunction cmd(t) QuickApp:trace(\"CMDEvent: \" ..t) end\r\n\r\nfunction badNew(origin,code)\r\n\tlocal txt = \"\"\r\n\tif code == 401 then txt = \"Permission Denied\" \r\n\telseif code == 404 then txt = \"Not Found\"\r\n\telseif code == 504 then txt = \"Gateway Timeout\"\r\n\telseif code == 800 then txt = \"Missing value\"\r\n\telse txt = \"Error unknown\"\r\n\tend\r\n\tQuickApp:error(origin .. \" # Code:\" .. code .. \" \" .. txt)\r\nend\r\n\r\nfunction TableConcat(t1,t2)\r\n    for k,v in pairs(t2) do t1[k] = v end\r\n    --[[for i=1, #t2 do\r\n        t1[#t1+1] = t2[i]\r\n    end]]\r\n    return t1\r\nend\r\nfunction toboolean(b)\r\n    if b == \"true\" then return true\r\n    elseif b == \"false\" then return false\r\n    elseif b == true or b == false then return b\r\n    else QuickApp:error(\"toboolean not work with \" .. b) return\r\n    end\r\nend\r\n\r\nfunction search(table,value)\r\n        for _,v in pairs(table) do\r\n            if v == value then return true end\r\n        end\r\n        return false\r\nend"},{"name":"fibaroExtra","isMain":false,"isOpen":true,"content":"fibaro = fibaro  or  {}\r\nfibaro.FIBARO_EXTRA = \"v0.917\"\r\nFILES = FILES or {}\r\nFILES['fibaroExtra']=fibaro.FIBARO_EXTRA\r\n\r\nlocal MID = plugin and plugin.mainDeviceId or sceneId or 0\r\nlocal format = string.format\r\nlocal function assertf(test,fmt,...) if not test then error(format(fmt,...),2) end end\r\nlocal debugFlags = {}\r\nlocal toTime,copy,equal,member,remove,protectFun\r\n\r\n-------------------- Utilities ----------------------------------------------\r\ndo\r\n  utils = {}\r\n  if not setTimeout then\r\n    function setTimeout(fun,ms) return fibaro.setTimeout(ms,fun) end\r\n    function clearTimeout(ref) fibaro.clearTimeout(ref) end\r\n    function setInterval(fun,ms) return fibaro.setInterval(ms,fun) end\r\n    function clearInterval(ref) fibaro.clearInterval(ref) end\r\n  end\r\n\r\n  function copy(obj)\r\n    if type(obj) == 'table' then\r\n      local res = {} for k,v in pairs(obj) do res[k] = copy(v) end\r\n      return res\r\n    else return obj end\r\n  end\r\n  utils.copy = copy \r\n\r\n  function utils.copyShallow(t)\r\n    if type(t)=='table' then\r\n      local r={}; for k,v in pairs(t) do r[k]=v end \r\n      return r \r\n    else return t end\r\n  end\r\n\r\n  function equal(e1,e2)\r\n    if e1==e2 then return true\r\n    else\r\n      if type(e1) ~= 'table' or type(e2) ~= 'table' then return false\r\n      else\r\n        for k1,v1 in pairs(e1) do if e2[k1] == nil or not equal(v1,e2[k1]) then return false end end\r\n        for k2,_  in pairs(e2) do if e1[k2] == nil then return false end end\r\n        return true\r\n      end\r\n    end\r\n  end\r\n  utils.equal=equal\r\n\r\n  if not table.maxn then \r\n    function table.maxn(tbl) local c=0; for _ in pairs(tbl) do c=c+1 end return c end\r\n  end\r\n\r\n  function utils.gensym(s) return (s or \"G\")..fibaro._orgToString({}):match(\"%s(.*)\") end\r\n  function member(k,tab) for i,v in ipairs(tab) do if equal(v,k) then return i end end return false end\r\n  function remove(obj,list) local i = member(obj,list); if i then table.remove(list,i) return true end end\r\n  utils.member,utils.remove = member,remove\r\n  function utils.remove(k,tab) local r = {}; for _,v in ipairs(tab) do if not equal(v,k) then r[#r+1]=v end end return r end\r\n  function utils.map(f,l) local r={}; for _,e in ipairs(l) do r[#r+1]=f(e) end; return r end\r\n  function utils.mapf(f,l) for _,e in ipairs(l) do f(e) end; end\r\n  function utils.mapAnd(f,l) for _,e in ipairs(l) do if f(e) then return false end end return true end\r\n  function utils.mapOr(f,l) for i,e in ipairs(l) do if f(e) then return i end end end\r\n  function utils.reduce(f,l) local r = {}; for _,e in ipairs(l) do if f(e) then r[#r+1]=e end end; return r end\r\n  function utils.mapk(f,l) local r={}; for k,v in pairs(l) do r[k]=f(v) end; return r end\r\n  function utils.mapkv(f,l) local r={}; for k,v in pairs(l) do k,v=f(k,v) r[k]=v end; return r end\r\n  function utils.size(t) local n=0; for _,_ in pairs(t) do n=n+1 end return n end \r\n\r\n  function utils.keyMerge(t1,t2)\r\n    local res = utils.copy(t1)\r\n    for k,v in pairs(t2) do if t1[k]==nil then t1[k]=v end end\r\n    return res\r\n  end\r\n\r\n  function utils.keyIntersect(t1,t2)\r\n    local res = {}\r\n    for k,v in pairs(t1) do if t2[k] then res[k]=v end end\r\n    return res\r\n  end\r\n\r\n  function utils.zip(fun,a,b,c,d) \r\n    local res = {}\r\n    for i=1,math.max(#a,#b) do res[#res+1] = fun(a[i],b[i],c and c[i],d and d[i]) end\r\n    return res\r\n  end\r\n\r\n  function utils.basicAuthorization(user,password) return \"Basic \"..utils.base64encode(user..\":\"..password) end\r\n  function utils.base64encode(data)\r\n    __assert_type(data,\"string\" )\r\n    local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n    return ((data:gsub('.', function(x) \r\n            local r,b='',x:byte() for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\r\n            return r;\r\n          end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\r\n          if (#x < 6) then return '' end\r\n          local c=0\r\n          for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\r\n          return b:sub(c+1,c+1)\r\n        end)..({ '', '==', '=' })[#data%3+1])\r\n  end\r\n\r\nend -- Utilities\r\n\r\n--------------------- Fibaro functions --------------------------------------\r\ndo\r\n  local HC3version = nil\r\n  function fibaro.HC3version(version)     -- Return/optional check HC3 version\r\n    if HC3version == nil then HC3version = api.get(\"/settings/info\").currentVersion.version end\r\n    if version then return version >= HC3version else return HC3version end \r\n  end\r\n\r\n  local IPaddress = nil\r\n  function fibaro.getIPaddress(name)\r\n    if IPaddress then return IPaddress end\r\n    if hc3_emulator then return hc3_emulator.IPaddress\r\n    else\r\n      name = name or \".*\"\r\n      local networkdata = api.get(\"/proxy?url=http://localhost:11112/api/settings/network\")\r\n      for n,d in pairs(networkdata.networkConfig or {}) do\r\n        if n:match(name) and d.enabled then IPaddress = d.ipConfig.ip; return IPaddress end\r\n      end\r\n    end\r\n  end\r\n\r\n\r\nend -- Fibaro functions\r\n\r\n--------------------- Time functions ------------------------------------------\r\ndo\r\n  local function toSeconds(str)\r\n    __assert_type(str,\"string\" )\r\n    local sun = str:match(\"(sun%a+)\") \r\n    if sun then return toSeconds(str:gsub(sun,fibaro.getValue(1,sun..\"Hour\"))) end\r\n    local var = str:match(\"(%$[A-Za-z]+)\") \r\n    if var then return toSeconds(str:gsub(var,fibaro.getGlobalVariable(var:sub(2)))) end\r\n    local h,m,s,op,off=str:match(\"(%d%d):(%d%d):?(%d*)([+%-]*)([%d:]*)\")\r\n    off = off~=\"\" and (off:find(\":\") and toSeconds(off) or toSeconds(\"00:00:\"..off)) or 0\r\n    return 3600*h+60*m+(s~=\"\" and s or 0)+((op=='-' or op =='+-') and -1 or 1)*off\r\n  end\r\n  fibaro.toSeconds = toSeconds\r\n\r\n  local function midnight() local t = os.date(\"*t\"); t.hour,t.min,t.sec = 0,0,0; return os.time(t) end\r\n  fibaro.midnight = midnight\r\n\r\n  function fibaro.between(start,stop,optTime)\r\n    __assert_type(start,\"string\" )\r\n    __assert_type(stop,\"string\" )\r\n    start,stop,optTime=toSeconds(start),toSeconds(stop),optTime and toSeconds(optTime) or toSeconds(os.date(\"%H:%M\"))\r\n    stop = stop>=start and stop or stop+24*3600\r\n    optTime = optTime>=start and optTime or optTime+24*3600\r\n    return start <= optTime and optTime <= stop\r\n  end\r\n\r\n  local function hm2sec(hmstr)\r\n    local offs,sun\r\n    sun,offs = hmstr:match(\"^(%a+)([+-]?%d*)\")\r\n    if sun and (sun == 'sunset' or sun == 'sunrise') then\r\n      hmstr,offs = fibaro.getValue(1,sun..\"Hour\"), tonumber(offs) or 0\r\n    end\r\n    local sg,h,m,s = hmstr:match(\"^(%-?)(%d+):(%d+):?(%d*)\")\r\n    assertf(h and m,\"Bad hm2sec string %s\",hmstr)\r\n    return (sg == '-' and -1 or 1)*(tonumber(h)*3600+tonumber(m)*60+(tonumber(s) or 0)+(tonumber(offs or 0))*60)\r\n  end\r\n\r\n-- toTime(\"10:00\")     -> 10*3600+0*60 secs   \r\n-- toTime(\"10:00:05\")  -> 10*3600+0*60+5*1 secs\r\n-- toTime(\"t/10:00\")    -> (t)oday at 10:00. midnight+10*3600+0*60 secs\r\n-- toTime(\"n/10:00\")    -> (n)ext time. today at 10.00AM if called before (or at) 10.00AM else 10:00AM next day\r\n-- toTime(\"+/10:00\")    -> Plus time. os.time() + 10 hours\r\n-- toTime(\"+/00:01:22\") -> Plus time. os.time() + 1min and 22sec\r\n-- toTime(\"sunset\")     -> todays sunset in relative secs since midnight, E.g. sunset=\"05:10\", =>toTime(\"05:10\")\r\n-- toTime(\"sunrise\")    -> todays sunrise\r\n-- toTime(\"sunset+10\")  -> todays sunset + 10min. E.g. sunset=\"05:10\", =>toTime(\"05:10\")+10*60\r\n-- toTime(\"sunrise-5\")  -> todays sunrise - 5min\r\n-- toTime(\"t/sunset+10\")-> (t)oday at sunset in 'absolute' time. E.g. midnight+toTime(\"sunset+10\")\r\n\r\n  function toTime(time)\r\n    if type(time) == 'number' then return time end\r\n    local p = time:sub(1,2)\r\n    if p == '+/' then return hm2sec(time:sub(3))+os.time()\r\n    elseif p == 'n/' then\r\n      local t1,t2 = midnight()+hm2sec(time:sub(3)),os.time()\r\n      return t1 > t2 and t1 or t1+24*60*60\r\n    elseif p == 't/' then return  hm2sec(time:sub(3))+midnight()\r\n    else return hm2sec(time) end\r\n  end\r\n  utils.toTime,utils.hm2sec = toTime,hm2sec\r\n\r\nend -- Time functions\r\n\r\n--------------------- Trace functions ------------------------------------------\r\n\r\n--------------------- Debug functions -----------------------------------------\r\ndo\r\n  local fformat\r\n  fibaro.debugFlags = debugFlags\r\n  debugFlags.debugLevel=nil\r\n  debugFlags.traceLevel=nil\r\n  debugFlags.notifyError=true\r\n  debugFlags.notifyWarning=true\r\n  debugFlags.onaction=true\r\n  debugFlags.uievent=true\r\n  debugFlags.json=true\r\n  debugFlags.html=true\r\n  debugFlags.reuseNotifies=true\r\n\r\n-- Add notification to notification center\r\n  local cachedNots = {}\r\n  local function notify(priority, text, reuse)\r\n    local id = MID\r\n    local idt = plugin and \"deviceId\" or \"sceneId\"\r\n    local name = quickApp and quickApp.name or tag or \"Scene\"\r\n    assert(({info=true,warning=true,alert=true})[priority],\"Wrong 'priority' - info/warning/alert\")\r\n    local title = text:match(\"(.-)[:%s]\") or format(\"%s deviceId:%d\",name,id)\r\n\r\n    if reuse==nil then reuse = debugFlags.reuseNotifies end\r\n    local msgId = nil\r\n    local data = {\r\n      canBeDeleted = true,\r\n      wasRead = false,\r\n      priority = priority,\r\n      type = \"GenericDeviceNotification\",\r\n      data = {\r\n        sceneId = sceneId,\r\n        deviceId = MID,\r\n        subType = \"Generic\",\r\n        title = title,\r\n        text = tostring(text)\r\n      }\r\n    }\r\n    local nid = title..id\r\n    if reuse then\r\n      if cachedNots[nid] then\r\n        msgId = cachedNots[nid]\r\n      else\r\n        for _,n in ipairs(api.get(\"/notificationCenter\") or {}) do\r\n          if n.data and (n.data.deviceId == id or n.data.sceneeId == id) and n.data.title == title then\r\n            msgId = n.id; break\r\n          end\r\n        end\r\n      end\r\n    end\r\n    if msgId then\r\n      api.put(\"/notificationCenter/\"..msgId, data)\r\n    else\r\n      local d = api.post(\"/notificationCenter\", data)\r\n      if d then cachedNots[nid] = d.id end\r\n    end\r\n  end\r\n  utils.notify = notify\r\n\r\n  local oldPrint = print\r\n  local inhibitPrint = {['onAction: ']='onaction', ['UIEvent: ']='uievent'}\r\n  function print(a,...) \r\n    if not inhibitPrint[a] or debugFlags[inhibitPrint[a]] then\r\n      oldPrint(a,...) \r\n    end\r\n  end\r\n\r\n  local old_tostring = tostring\r\n  fibaro._orgToString = old_tostring\r\n  if hc3_emulator then\r\n    function tostring(obj)\r\n      if type(obj)=='table' and not hc3_emulator.getmetatable(obj) then\r\n        if obj.__tostring then return obj.__tostring(obj) \r\n        elseif debugFlags.json then return json.encodeFast(obj) end\r\n      end\r\n      return old_tostring(obj)\r\n    end\r\n  else\r\n    function tostring(obj)\r\n      if type(obj)=='table' then\r\n        if obj.__tostring then return obj.__tostring(obj) \r\n        elseif debugFlags.json then return json.encodeFast(obj) end\r\n      end\r\n      return old_tostring(obj)\r\n    end\r\n  end\r\n\r\n  local htmlCodes={['\\n']='<br>', [' ']='&nbsp;'}\r\n  local function fix(str) return str:gsub(\"([\\n%s])\",function(c) return htmlCodes[c] or c end) end\r\n  local function htmlTransform(str)\r\n    local hit = false\r\n    str = str:gsub(\"([^<]*)(<.->)([^<]*)\",function(s1,s2,s3) hit=true\r\n        return (s1~=\"\" and fix(s1) or \"\")..s2..(s3~=\"\" and fix(s3) or \"\") \r\n      end)\r\n    return hit and str or fix(str)\r\n  end\r\n\r\n  function fformat(fmt,...)\r\n    local args = {...}\r\n    if #args == 0 then return tostring(fmt) end\r\n    for i,v in ipairs(args) do if type(v)=='table' then args[i]=tostring(v) end end\r\n    return (debugFlags.html and not hc3_emulator) and htmlTransform(format(fmt,table.unpack(args))) or format(fmt,table.unpack(args))\r\n  end\r\n\r\n  local function arr2str(...)\r\n    local args,res = {...},{}\r\n    for i=1,#args do if args[i]~=nil then res[#res+1]=tostring(args[i]) end end \r\n    return (debugFlags.html and not hc3_emulator) and htmlTransform(table.concat(res,\" \")) or table.concat(res,\" \")\r\n  end \r\n\r\n  local function print_debug(typ,tag,str)\r\n    api.post(\"/debugMessages\",{\r\n        messageType=typ or \"debug\",\r\n        message = str or \"\",\r\n        tag = tag or __TAG\r\n      })\r\n    return str\r\n  end\r\n\r\n  function fibaro.debug(tag,...) \r\n    if not(type(tag)=='number' and tag > (debugFlags.debugLevel or 0)) then \r\n      return print_debug('debug',tag,arr2str(...)) \r\n    else return \"\" end \r\n  end\r\n  function fibaro.trace(tag,...) \r\n    if not(type(tag)=='number' and tag > (debugFlags.traceLevel or 0)) then \r\n      return print_debug('trace',tag,arr2str(...)) \r\n    else return \"\" end \r\n  end\r\n  function fibaro.error(tag,...)\r\n    local str = print_debug('error',tag,arr2str(...))\r\n    if debugFlags.notifyError then notify(\"alert\",str) end\r\n    return str\r\n  end\r\n  function fibaro.warning(tag,...) \r\n    local str = print_debug('warning',tag,arr2str(...))\r\n    if debugFlags.notifyWarning then notify(\"warning\",str) end\r\n    return str\r\n  end\r\n  function fibaro.debugf(tag,fmt,...) \r\n    if not(type(tag)=='number' and tag > (debugFlags.debugLevel or 0)) then \r\n      return print_debug('debug',tag,fformat(fmt,...)) \r\n    else return \"\" end \r\n  end\r\n  function fibaro.tracef(tag,fmt,...) \r\n    if not(type(tag)=='number' and tag > (debugFlags.traceLevel or 0)) then \r\n      return print_debug('trace',tag,fformat(fmt,...)) \r\n    else return \"\" end \r\n  end\r\n  function fibaro.errorf(tag,fmt,...)\r\n    local str = print_debug('error',tag,fformat(fmt,...)) \r\n    if debugFlags.notifyError then notify(\"alert\",str) end\r\n    return str\r\n  end\r\n  function fibaro.warningf(tag,fmt,...) \r\n    local str = print_debug('warning',tag,fformat(fmt,...)) \r\n    if debugFlags.notifyWarning then notify(\"warning\",str) end\r\n    return str\r\n  end\r\n\r\n  function protectFun(fun,f,level)\r\n    return function(...)\r\n      local stat,res = pcall(fun,...)\r\n      if not stat then\r\n        res = res:gsub(\"fibaroExtra.lua:%d+:\",\"\")..\"(\"..f..\")\"\r\n        error(res,level) \r\n      else return res end\r\n    end\r\n  end\r\n\r\n  for _,f in ipairs({'debugf','tracef','warningf','errorf'}) do\r\n    fibaro[f] = protectFun(fibaro[f],f,2)\r\n  end\r\n\r\nend -- Debug functions\r\n\r\n--------------------- Scene function  -----------------------------------------\r\ndo\r\n  function fibaro.isSceneEnabled(sceneID) \r\n    __assert_type(sceneID,\"number\" )\r\n    return (api.get(\"/scenes/\"..sceneID) or { enabled=false }).enabled \r\n  end\r\n\r\n  function fibaro.setSceneEnabled(sceneID,enabled) \r\n    __assert_type(sceneID,\"number\" )   __assert_type(enabled,\"boolean\" )\r\n    return api.put(\"/scenes/\"..sceneID,{enabled=enabled}) \r\n  end\r\n\r\n  function fibaro.getSceneRunConfig(sceneID)\r\n    __assert_type(sceneID,\"number\" )\r\n    return api.get(\"/scenes/\"..sceneID).mode \r\n  end\r\n\r\n  function fibaro.setSceneRunConfig(sceneID,runConfig)\r\n    __assert_type(sceneID,\"number\" )\r\n    assert(({automatic=true,manual=true})[runConfig],\"runconfig must be 'automatic' or 'manual'\")\r\n    return api.put(\"/scenes/\"..sceneID, {mode = runConfig}) \r\n  end\r\n\r\n\r\nend -- Scene function\r\n\r\n--------------------- Globals --------------------------------------------------\r\ndo\r\n  function fibaro.getAllGlobalVariables() \r\n    return utils.map(function(v) return v.name end,api.get(\"/globalVariables\")) \r\n  end\r\n\r\n  function fibaro.createGlobalVariable(name,value,options)\r\n    __assert_type(name,\"string\")\r\n    if not fibaro.existGlobalVariable(name) then \r\n      value = tostring(value)\r\n      local args = utils.copy(options or {})\r\n      args.name,args.value=name,value\r\n      return api.post(\"/globalVariables\",args)\r\n    end\r\n  end\r\n\r\n  function fibaro.deleteGlobalVariable(name) \r\n    __assert_type(name,\"string\")\r\n    return api.delete(\"/globalVariable/\"..name) \r\n  end\r\n\r\n  function fibaro.existGlobalVariable(name)\r\n    __assert_type(name,\"string\")\r\n    return api.get(\"/globalVariable/\"..name) and true \r\n  end\r\n\r\n  function fibaro.getGlobalVariableType(name)\r\n    __assert_type(name,\"string\")\r\n    local v = api.get(\"/globalVariable/\"..name) or {}\r\n    return v.isEnum,v.readOnly\r\n  end\r\n\r\n  function fibaro.getGlobalVariableLastModified(name)\r\n    __assert_type(name,\"string\")\r\n    return (api.get(\"/globalVariable/\"..name) or {}).modified \r\n  end\r\n\r\n\r\nend -- Globals\r\n\r\n--------------------- Custom events --------------------------------------------\r\ndo\r\n  function fibaro.getAllCustomEvents() \r\n    return utils.map(function(v) return v.name end,api.get(\"/customEvents\") or {}) \r\n  end\r\n\r\n  function fibaro.createCustomEvent(name,userDescription) \r\n    __assert_type(name,\"string\" )\r\n    return api.post(\"/customEvent\",{name=name,uderDescription=userDescription or \"\"})\r\n  end\r\n\r\n  function fibaro.deleteCustomEvent(name) \r\n    __assert_type(name,\"string\" )\r\n    return api.delete(\"/customEvents/\"..name) \r\n  end\r\n\r\n  function fibaro.existCustomEvent(name) \r\n    __assert_type(name,\"string\" )\r\n    return api.get(\"/customEvents/\"..name) and true \r\n  end\r\n\r\n\r\nend -- Custom events\r\n\r\n--------------------- Profiles -------------------------------------------------\r\ndo\r\n  function fibaro.activeProfile(id)\r\n    if id then\r\n      if type(id)=='string' then id = fibaro.profileNameToId(id) end\r\n      assert(id,\"fibaro.getActiveProfile(id) - no such id/name\")\r\n      return api.put(\"/profiles\",{activeProfile=id}) and id\r\n    end\r\n    return api.get(\"/profiles\").activeProfile \r\n  end\r\n\r\n  function fibaro.profileIdtoName(pid)\r\n    __assert_type(pid,\"number\")\r\n    for _,p in ipairs(api.get(\"/profiles\").profiles or {}) do \r\n      if p.id == pid then return p.name end \r\n    end \r\n  end\r\n\r\n  function fibaro.profileNameToId(name)\r\n    __assert_type(name,\"string\")\r\n    for _,p in ipairs(api.get(\"/profiles\").profiles or {}) do \r\n      if p.name == name then return p.id end \r\n    end \r\n  end\r\n\r\n\r\nend -- Profiles\r\n\r\n--------------------- Alarm functions ------------------------------------------\r\ndo\r\n  function fibaro.partitionIdToName(pid)\r\n    __assert_type(pid,\"number\")\r\n    return (api.get(\"/alarms/v1/partitions/\"..pid) or {}).name \r\n  end\r\n\r\n  function fibaro.partitionNameToId(name)\r\n    assert(type(name)=='string',\"Alarm partition name not a string\")\r\n    for _,p in ipairs(api.get(\"/alarms/v1/partitions\") or {}) do\r\n      if p.name == name then return p.id end\r\n    end\r\n  end\r\n\r\n-- Returns devices breached in partition 'pid'\r\n  function fibaro.getBreachedDevicesInPartition(pid)\r\n    assert(type(pid)=='number',\"Alarm partition id not a number\")\r\n    local p,res = api.get(\"/alarms/v1/partitions/\"..pid),{}\r\n    for _,d in ipairs((p or {}).devices or {}) do\r\n      if fibaro.getValue(d,\"value\") then res[#res+1]=d end\r\n    end\r\n    return res\r\n  end\r\n\r\n-- helper function\r\n  local function filterPartitions(filter)\r\n    local res = {}\r\n    for _,p in ipairs(api.get(\"/alarms/v1/partitions\") or {}) do if filter(p) then res[#res+1]=p.id end end\r\n    return res\r\n  end\r\n\r\n-- Return all partitions ids\r\n  function fibaro.getAllPartitions() return filterPartitions(function() return true end) end\r\n\r\n-- Return partitions that are armed\r\n  function fibaro.getArmedPartitions() return filterPartitions(function(p) return p.armed end) end\r\n\r\n-- Return partitions that are about to be armed\r\n  function fibaro.getActivatedPartitions() return filterPartitions(function(p) return p.secondsToArm end) end\r\n\r\n-- Return breached partitions\r\n  function fibaro.getBreachedPartitions() return api.get(\"/alarms/v1/partitions/breached\") or {} end\r\n\r\n--If you want to list all devices that can be part of a alarm partition/zone you can do\r\n  function fibaro.getAlarmDevices() return api.get(\"/alarms/v1/devices/\") end\r\n\r\n  fibaro.ALARM_INTERVAL = 1000\r\n  local fun\r\n  local ref\r\n  local armedPs={}\r\n  local function watchAlarms()\r\n    for _,p in ipairs(api.get(\"/alarms/v1/partitions\") or {}) do\r\n      if p.secondsToArm and not armedPs[p.id] then\r\n        setTimeout(function() pcall(fun,p.id) end,0)\r\n      end\r\n      armedPs[p.id] = p.secondsToArm\r\n    end\r\n  end\r\n  function fibaro.activatedPartitions(callback)\r\n    __assert_type(callback,\"function\")\r\n    fun = callback\r\n    if fun and ref == nil then\r\n      ref = setInterval(watchAlarms,fibaro.ALARM_INTERVAL)\r\n    elseif fun == nil and ref then\r\n      clearInterval(ref); ref = nil \r\n    end\r\n  end\r\n\r\n--[[ Ex. check what partitions have breached devices\r\nfor _,p in ipairs(getAllPartitions()) do\r\n  local bd = getBreachedDevicesInPartition(p)\r\n  if bd[1] then print(\"Partition \"..p..\" contains breached devices \"..json.encode(bd)) end\r\nend\r\n--]]\r\n\r\nend -- Alarm\r\n\r\n--------------------- Weather --------------------------------------------------\r\ndo\r\n  fibaro.weather = {}\r\n  function fibaro.weather.temperature() return api.get(\"/weather\").Temperature end\r\n  function fibaro.weather.temperatureUnit() return api.get(\"/weather\").TemperatureUnit end\r\n  function fibaro.weather.humidity() return api.get(\"/weather\").Humidity end\r\n  function fibaro.weather.wind() return api.get(\"/weather\").Wind end\r\n  function fibaro.weather.weatherCondition() return api.get(\"/weather\").WeatherCondition end\r\n  function fibaro.weather.conditionCode() return api.get(\"/weather\").ConditionCode end\r\n\r\nend --Weather\r\n\r\n--------------------- sourceTrigger & refreshStates ----------------------------\r\ndo\r\n  fibaro.REFRESH_STATES_INTERVAL = 1000\r\n  local sourceTriggerCallbacks,refreshCallbacks,refreshRef,pollRefresh={},{}\r\n  local ENABLEDSOURCETRIGGERS,DISABLEDREFRESH={},{}\r\n  local post,sourceTriggerTransformer,filter\r\n\r\n  local EventTypes = { -- There are more, but these are what I seen so far...\r\n    AlarmPartitionArmedEvent = function(d) post({type='alarm', property='armed', id = d.partitionId, value=d.armed}) end,\r\n    AlarmPartitionBreachedEvent = function(d) post({type='alarm', property='breached', id = d.partitionId, value=d.breached}) end,\r\n    HomeArmStateChangedEvent = function(d) post({type='alarm', property='homeArmed', value=d.newValue}) end,\r\n    HomeBreachedEvent = function(d) post({type='alarm', property='homeBreached', value=d.breached}) end,\r\n    WeatherChangedEvent = function(d) post({type='weather',property=d.change, value=d.newValue, old=d.oldValue}) end,\r\n    GlobalVariableChangedEvent = function(d) \r\n      post({type='global-variable', name=d.variableName, value=d.newValue, old=d.oldValue}) \r\n    end,\r\n    DevicePropertyUpdatedEvent = function(d)\r\n      if d.property=='quickAppVariables' then \r\n        local old={}; for _,v in ipairs(d.oldValue) do old[v.name] = v.value end -- Todo: optimize\r\n        for _,v in ipairs(d.newValue) do\r\n          if not equal(v.value,old[v.name]) then\r\n            post({type='quickvar', id=d.id, name=v.name, value=v.value, old=old[v.name]})\r\n          end\r\n        end\r\n      else\r\n        if d.property == \"icon\" or filter(d.id,d.property,d.newValue) then return end\r\n        post({type='device', id=d.id, property=d.property, value=d.newValue, old=d.oldValue})\r\n      end\r\n    end,\r\n    CentralSceneEvent = function(d) \r\n      d.id = d.id or d.deviceId\r\n      d.icon=nil \r\n      post({type='device', property='centralSceneEvent', id=d.id, value={keyId=d.keyId, keyAttribute=d.keyAttribute}}) \r\n    end,\r\n    SceneActivationEvent = function(d) \r\n      d.id = d.id or d.deviceId\r\n      post({type='device', property='sceneActivationEvent', id=d.id, value={sceneId=d.sceneId}})     \r\n    end,\r\n    AccessControlEvent = function(d) \r\n      post({type='device', property='accessControlEvent', id=d.id, value=d}) \r\n    end,\r\n    CustomEvent = function(d) \r\n      local value = api.get(\"/customEvents/\"..d.name) \r\n      post({type='custom-event', name=d.name, value=value and value.userDescription}) \r\n    end,\r\n    PluginChangedViewEvent = function(d) post({type='PluginChangedViewEvent', value=d}) end,\r\n    WizardStepStateChangedEvent = function(d) post({type='WizardStepStateChangedEvent', value=d})  end,\r\n    UpdateReadyEvent = function(d) post({type='updateReadyEvent', value=d}) end,\r\n    DeviceRemovedEvent = function(d)  post({type='deviceEvent', id=d.id, value='removed'}) end,\r\n    DeviceChangedRoomEvent = function(d)  post({type='deviceEvent', id=d.id, value='changedRoom'}) end,\r\n    DeviceCreatedEvent = function(d)  post({type='deviceEvent', id=d.id, value='created'}) end,\r\n    DeviceModifiedEvent = function(d) post({type='deviceEvent', id=d.id, value='modified'}) end,\r\n    PluginProcessCrashedEvent = function(d) post({type='deviceEvent', id=d.deviceId, value='crashed', error=d.error}) end,\r\n    SceneStartedEvent = function(d)   post({type='sceneEvent', id=d.id, value='started'}) end,\r\n    SceneFinishedEvent = function(d)  post({type='sceneEvent', id=d.id, value='finished'})end,\r\n    SceneRunningInstancesEvent = function(d) post({type='sceneEvent', id=d.id, value='instance', instance=d}) end,\r\n    SceneRemovedEvent = function(d)  post({type='sceneEvent', id=d.id, value='removed'}) end,\r\n    SceneCreatedEvent = function(d)  post({type='sceneEvent', id=d.id, value='created'}) end,\r\n    OnlineStatusUpdatedEvent = function(d) post({type='onlineEvent', value=d.online}) end,\r\n    --onUIEvent = function(d) post({type='uievent', deviceID=d.deviceId, name=d.elementName}) end,\r\n    ActiveProfileChangedEvent = function(d) \r\n      post({type='profile',property='activeProfile',value=d.newActiveProfile, old=d.oldActiveProfile}) \r\n    end,\r\n    ClimateZoneChangedEvent = function(d) d.type = 'ClimateZoneChangedEvent' post(d) end,\r\n    ClimateZoneSetpointChangedEvent = function(d) d.type = 'ClimateZoneSetpointChangedEvent' post(d) end,\r\n    NotificationCreatedEvent = function(d) post({type='notification', id=d.id, value='created'}) end,\r\n    NotificationRemovedEvent = function(d) post({type='notification', id=d.id, value='removed'}) end,\r\n    NotificationUpdatedEvent = function(d) post({type='notification', id=d.id, value='updated'}) end,\r\n    RoomCreatedEvent = function(d) post({type='room', id=d.id, value='created'}) end,\r\n    RoomRemovedEvent = function(d) post({type='room', id=d.id, value='removed'}) end,\r\n    RoomModifiedEvent = function(d) post({type='room', id=d.id, value='modified'}) end,\r\n    SectionCreatedEvent = function(d) post({type='section', id=d.id, value='created'}) end,\r\n    SectionRemovedEvent = function(d) post({type='section', id=d.id, value='removede'}) end,\r\n    SectionModifiedEvent = function(d) post({type='section', id=d.id, value='modified'}) end,\r\n    DeviceActionRanEvent = function(_) end,\r\n    QuickAppFilesChangedEvent = function(_) end,\r\n    ZwaveDeviceParametersChangedEvent = function(_) end,\r\n    ZwaveNodeAddedEvent = function(_) end,\r\n    RefreshRequiredEvent = function(_) end,\r\n    DeviceFirmwareUpdateEvent = function(_) end,\r\n    GeofenceEvent = function(d) \r\n      post({type='location',id=d.userId,property=d.locationId,value=d.geofenceAction,timestamp=d.timestamp})\r\n    end,\r\n  }\r\n\r\n  function fibaro.registerSourceTriggerCallback(callback)\r\n    __assert_type(callback,\"function\")\r\n    if member(callback,sourceTriggerCallbacks) then return end\r\n    if #sourceTriggerCallbacks == 0 then\r\n      fibaro.registerRefreshStatesCallback(sourceTriggerTransformer)\r\n    end\r\n    sourceTriggerCallbacks[#sourceTriggerCallbacks+1] = callback\r\n  end\r\n\r\n  function fibaro.unregisterSourceTriggerCallback(callback)\r\n    __assert_type(callback,\"function\")\r\n    if member(callback,sourceTriggerCallbacks) then remove(callback,sourceTriggerCallbacks) end\r\n    if #sourceTriggerCallbacks == 0 then\r\n      fibaro.unregisterRefreshStatesCallback(sourceTriggerTransformer) \r\n    end\r\n  end\r\n\r\n  function post(ev)\r\n    if ENABLEDSOURCETRIGGERS[ev.type] then\r\n      if #sourceTriggerCallbacks==0 then return end\r\n      if debugFlags.sourceTrigger then fibaro.debugf(nil,\"Incoming sourceTrigger:%s\",ev) end\r\n      ev._trigger=true\r\n      for _,cb in ipairs(sourceTriggerCallbacks) do\r\n        setTimeout(function() cb(ev) end,0) \r\n      end\r\n    end\r\n  end\r\n\r\n  function sourceTriggerTransformer(e)\r\n    local handler = EventTypes[e.type]\r\n    if handler then handler(e.data)\r\n    elseif handler==nil and fibaro._UNHANDLED_REFRESHSTATES then \r\n      fibaro.debugf(__TAG,\"[Note] Unhandled refreshState/sourceTrigger:%s -- please report\",e) \r\n    end\r\n  end\r\n\r\n  function fibaro.enableSourceTriggers(trigger)\r\n    if type(trigger)~='table' then  trigger={trigger} end\r\n    for _,t in  ipairs(trigger) do ENABLEDSOURCETRIGGERS[t]=true end\r\n  end\r\n  fibaro.enableSourceTriggers({\"device\",\"alarm\",\"global-variable\",\"custom-event\",\"quickvar\"})\r\n\r\n  function fibaro.disableSourceTriggers(trigger)\r\n    if type(trigger)~='table' then  trigger={trigger} end\r\n    for _,t in  ipairs(trigger) do ENABLEDSOURCETRIGGERS[t]=nil end\r\n  end\r\n\r\n  local propFilters = {}\r\n  function fibaro.sourceTriggerDelta(id,prop,value)\r\n    __assert_type(id,\"number\")\r\n    __assert_type(prop,\"string\")\r\n    local d = propFilters[id] or {}\r\n    d[prop] =  {delta = value}\r\n    propFilters[id] = d\r\n  end\r\n\r\n  function filter(id,prop,new)\r\n    local d = (propFilters[id] or {})[prop]\r\n    if d then\r\n      if d.last == nil then \r\n        d.last = new\r\n        return false\r\n      else\r\n        if math.abs(d.last-new) >= d.delta then\r\n          d.last = new\r\n          return false\r\n        else return true end\r\n      end\r\n    else return false end\r\n  end\r\n\r\n  fibaro._REFRESHSTATERATE = 1000\r\n  local lastRefresh = 0\r\n  net = net or { HTTPClient = function() end  }\r\n  local http = net.HTTPClient()\r\n  math.randomseed(os.time())\r\n  local urlTail = \"&lang=en&rand=\"..math.random(2000,4000)..\"&logs=false\"\r\n  function pollRefresh()\r\n    local _,_ = http:request(\"http://127.0.0.1:11111/api/refreshStates?last=\" .. lastRefresh..urlTail,{\r\n        success=function(res)\r\n          local states = res.status == 200 and json.decode(res.data)\r\n          if states then\r\n            lastRefresh=states.last\r\n            if states.events and #states.events>0 then \r\n              for _,e in ipairs(states.events) do\r\n                fibaro._postRefreshState(e)\r\n              end\r\n            end\r\n          end \r\n          refreshRef = setTimeout(pollRefresh,fibaro.REFRESH_STATES_INTERVAL or 0)\r\n        end,\r\n        error=function(res) \r\n          fibaro.errorf(__TAG,\"refreshStates:%s\",res)\r\n          refreshRef = setTimeout(pollRefresh,fibaro._REFRESHSTATERATE)\r\n        end,\r\n      })\r\n  end\r\n\r\n  function fibaro.registerRefreshStatesCallback(callback)\r\n    __assert_type(callback,\"function\")\r\n    if member(callback,refreshCallbacks) then return end\r\n    refreshCallbacks[#refreshCallbacks+1] = callback\r\n    if not refreshRef then refreshRef = setTimeout(pollRefresh,0) end\r\n    if debugFlags._refreshStates then fibaro.debug(__TAG,\"Polling for refreshStates\") end\r\n  end\r\n\r\n  function fibaro.unregisterRefreshStatesCallback(callback)\r\n    remove(callback,refreshCallbacks)\r\n    if #refreshCallbacks == 0 then\r\n      if refreshRef then clearTimeout(refreshRef); refreshRef = nil end\r\n      if debugFlags._refreshStates then fibaro.debug(nil,\"Stop polling for refreshStates\") end\r\n    end\r\n  end\r\n\r\n  function fibaro.enableRefreshStatesTypes(typs) \r\n    if  type(typs)~='table' then typs={typs} end\r\n    for _,t in ipairs(typs) do DISABLEDREFRESH[t]=nil end\r\n  end\r\n\r\n  function fibaro.disableRefreshStatesTypes(typs)\r\n    if  type(typs)~='table' then typs={typs} end\r\n    for _,t in ipairs(typs) do DISABLEDREFRESH[t]=true end\r\n  end\r\n\r\n  function fibaro._postSourceTrigger(trigger) post(trigger) end\r\n\r\n  function fibaro._postRefreshState(event)\r\n    if #refreshCallbacks>0 and not DISABLEDREFRESH[event.type] then\r\n      for i=1,#refreshCallbacks do\r\n        setTimeout(function() refreshCallbacks[i](event) end,0)\r\n      end\r\n    end\r\n  end\r\n\r\n  function fibaro.postGeofenceEvent(userId,locationId,geofenceAction)\r\n    __assert_type(userId,\"number\")\r\n    __assert_type(locationId,\"number\")\r\n    __assert_type(geofenceAction,\"string\")\r\n    return api.post(\"/events/publishEvent/GeofenceEvent\",\r\n      {\r\n        deviceId = MID,\r\n        userId\t= userId,\r\n        locationId\t= locationId,\r\n        geofenceAction = geofenceAction,\r\n        timestamp = os.time()\r\n      })\r\n  end\r\n\r\n  function fibaro.postCentralSceneEvent(keyId,keyAttribute)\r\n    local data = {\r\n      type =  \"centralSceneEvent\",\r\n      source = MID,\r\n      data = { keyAttribute = keyAttribute, keyId = keyId }\r\n    }\r\n    return api.post(\"/plugins/publishEvent\", data)\r\n  end\r\nend -- sourceTrigger & refreshStates\r\n\r\n--------------------- Net functions --------------------------------------------\r\ndo\r\n  netSync = { HTTPClient = function(args)\r\n      local self,queue,HTTP,key = {},{},net.HTTPClient(args),0\r\n      local _request\r\n      local function dequeue()\r\n        table.remove(queue,1)\r\n        local v = queue[1]\r\n        if v then \r\n          --if _debugFlags.netSync then self:debugf(\"netSync:Pop %s (%s)\",v[3],#queue) end\r\n          --setTimeout(function() _request(table.unpack(v)) end,1) \r\n          _request(table.unpack(v))\r\n        end\r\n      end\r\n      _request = function(url,params,key)\r\n        params = copy(params)\r\n        local uerr,usucc = params.error,params.success\r\n        params.error = function(status)\r\n          --if _debugFlags.netSync then self:debugf(\"netSync:Error %s %s\",key,status) end\r\n          dequeue()\r\n          --if params._logErr then self:errorf(\" %s:%s\",log or \"netSync:\",tojson(status)) end\r\n          if uerr then uerr(status) end\r\n        end\r\n        params.success = function(status)\r\n          --if _debugFlags.netSync then self:debugf(\"netSync:Success %s\",key) end\r\n          dequeue()\r\n          if usucc then usucc(status) end\r\n        end\r\n        --if _debugFlags.netSync then self:debugf(\"netSync:Calling %s\",key) end\r\n        HTTP:request(url,params)\r\n      end\r\n      function self:request(url,parameters)\r\n        key = key+1\r\n        if next(queue) == nil then\r\n          queue[1]='RUN'\r\n          _request(url,parameters,key)\r\n        else \r\n          --if _debugFlags.netSync then self:debugf(\"netSync:Push %s\",key) end\r\n          queue[#queue+1]={url,parameters,key} \r\n        end\r\n      end\r\n      return self\r\n    end}\r\nend -- Net functions\r\n\r\n--------------------- QA functions ---------------------------------------------\r\ndo\r\n  function fibaro.restartQA(id)\r\n    __assert_type(id,\"number\")\r\n    return api.post(\"/plugins/restart\",{deviceId=id or MID})\r\n  end\r\n\r\n  function fibaro.getQAVariable(id,name)\r\n    __assert_type(id,\"number\")\r\n    __assert_type(name,\"string\")\r\n    local props = (api.get(\"/devices/\"..(id or MID)) or {}).properties or {}\r\n    for _, v in ipairs(props.quickAppVariables or {}) do\r\n      if v.name==name then return v.value end\r\n    end\r\n  end\r\n\r\n  function fibaro.setQAVariable(id,name,value)\r\n    __assert_type(id,\"number\")\r\n    __assert_type(name,\"string\")\r\n    return fibaro.call(id,\"setVariable\",name,value)\r\n  end\r\n\r\n  function fibaro.getAllQAVariables(id)\r\n    __assert_type(id,\"number\")\r\n    local props = (api.get(\"/devices/\"..(id or MID)) or {}).properties or {}\r\n    local res = {}\r\n    for _, v in ipairs(props.quickAppVariables or {}) do\r\n      res[v.name]=v.value\r\n    end\r\n    return res\r\n  end\r\n\r\n  function fibaro.isQAEnabled(id)\r\n    __assert_type(id,\"number\")\r\n    local dev = api.get(\"/devices/\"..(id or MID))\r\n    return (dev or {}).enabled\r\n  end\r\n\r\n  function fibaro.enableQA(id,enable)\r\n    __assert_type(id,\"number\")\r\n    __assert_type(enable,\"boolean\")\r\n    return api.post(\"/devices/\"..(id or MID),{enabled=enable==true})\r\n  end\r\n\r\n  if QuickApp then\r\n\r\n    local _init = QuickApp.__init\r\n    local _onInit = nil\r\n    local loadQA\r\n\r\n    function QuickApp.__init(self,...) -- We hijack the __init methods so we can control users :onInit() method\r\n      _onInit = self.onInit\r\n      self.onInit = loadQA\r\n      _init(self,...)\r\n    end\r\n\r\n    function loadQA(self)\r\n      local dev = __fibaro_get_device(self.id)\r\n      if not dev.enabled then  \r\n        self:debug(\"QA \",self.name,\" disabled\")\r\n        return \r\n      end\r\n      self.config = {}\r\n      for _,v in ipairs(dev.properties.quickAppVariables or {}) do\r\n        if v.value ~= \"\" then self.config[v.name] = v.value end\r\n      end\r\n      quickApp = self\r\n      if _onInit then _onInit(self) end\r\n    end\r\n\r\n    function QuickApp:debug(...) fibaro.debug(nil,...) end\r\n    function QuickApp:trace(...) fibaro.trace(nil,...) end\r\n    function QuickApp:warning(...) fibaro.warning(nil,...) end\r\n    function QuickApp:error(...) fibaro.error(nil,...) end\r\n    function QuickApp:debugf(...) fibaro.debugf(nil,...) end\r\n    function QuickApp:tracef(...) fibaro.tracef(nil,...) end\r\n    function QuickApp:warningf(...) fibaro.warningf(nil,...) end\r\n    function QuickApp:errorf(...) fibaro.errorf(nil,...) end\r\n    function QuickApp:debug2(tl,...) fibaro.debug(tl,...) end\r\n    function QuickApp:trace2(tl,...) fibaro.trace(tl,...) end\r\n    function QuickApp:warning2(tl,...) fibaro.warning(tl,...) end\r\n    function QuickApp:error2(tl,...) fibaro.error(tl,...) end\r\n    function QuickApp:debugf2(tl,...) fibaro.debugf(tl,...) end\r\n    function QuickApp:tracef2(tl,...) fibaro.tracef(tl,...) end\r\n    function QuickApp:warningf2(tl,...) fibaro.warningf(tl,...) end\r\n    function QuickApp:errorf2(tl,...) fibaro.errorf(tl,...) end\r\n\r\n    for _,f in ipairs({'debugf','tracef','warningf','errorf','debugf2','tracef2','warningf2','errorf2'}) do\r\n      QuickApp[f]=protectFun(QuickApp[f],f,2)\r\n    end\r\n\r\n-- Like self:updateView but with formatting. Ex self:setView(\"label\",\"text\",\"Now %d days\",days)\r\n    function QuickApp:setView(elm,prop,fmt,...)\r\n      local str = format(fmt,...)\r\n      self:updateView(elm,prop,str)\r\n    end\r\n\r\n-- Get view element value. Ex. self:getView(\"mySlider\",\"value\")\r\n    function QuickApp:getView(elm,prop)\r\n      assert(type(elm)=='string' and type(prop)=='string',\"Strings expected as arguments\")\r\n      local function find(s)\r\n        if type(s) == 'table' then\r\n          if s.name==elm then return s[prop]\r\n          else for _,v in pairs(s) do local r = find(v) if r then return r end end end\r\n        end\r\n      end\r\n      return find(api.get(\"/plugins/getView?id=\"..self.id)[\"$jason\"].body.sections)\r\n    end\r\n\r\n-- Change name of QA. Note, if name is changed the QA will restart\r\n    function QuickApp:setName(name)\r\n      if self.name ~= name then api.put(\"/devices/\"..self.id,{name=name}) end\r\n      self.name = name\r\n    end\r\n\r\n-- Set log text under device icon - optional timeout to clear the message\r\n    function QuickApp:setIconMessage(msg,timeout)\r\n      if self._logTimer then clearTimeout(self._logTimer) self._logTimer=nil end\r\n      self:updateProperty(\"log\", tostring(msg))\r\n      if timeout then \r\n        self._logTimer=setTimeout(function() self:updateProperty(\"log\",\"\"); self._logTimer=nil end,1000*timeout) \r\n      end\r\n    end\r\n\r\n-- Disable QA. Note, difficult to enable QA...\r\n    function QuickApp:setEnabled(bool)\r\n      local d = __fibaro_get_device(self.id)\r\n      if d.enabled ~= bool then api.put(\"/devices/\"..self.id,{enabled=bool}) end\r\n    end\r\n\r\n-- Hide/show QA. Note, if state is changed the QA will restart\r\n    function QuickApp:setVisible(bool) \r\n      local d = __fibaro_get_device(self.id)\r\n      if d.visible ~= bool then api.put(\"/devices/\"..self.id,{visible=bool}) end\r\n    end\r\n\r\n    function QuickApp:post(...) return fibaro.post(...) end\r\n    function QuickApp:event(...) return fibaro.event(...) end\r\n\r\n    function fibaro.deleteFile(deviceId,file)\r\n      local name = type(file)=='table' and file.name or file\r\n      return api.delete(\"/quickApp/\"..(deviceId or MID)..\"/files/\"..name)\r\n    end\r\n\r\n    function fibaro.updateFile(deviceId,file,content)\r\n      if type(file)=='string' then\r\n        file = {isMain=false,type='lua',isOpen=false,name=file,content=\"\"}\r\n      end\r\n      file.content = type(content)=='string' and content or file.content\r\n      return api.put(\"/quickApp/\"..(deviceId or MID)..\"/files/\"..file.name,file) \r\n    end\r\n\r\n    function fibaro.updateFiles(deviceId,list)\r\n      if #list == 0 then return true end\r\n      return api.put(\"/quickApp/\"..(deviceId or MID)..\"/files\",list) \r\n    end\r\n\r\n    function fibaro.createFile(deviceId,file,content)\r\n      if type(file)=='string' then\r\n        file = {isMain=false,type='lua',isOpen=false,name=file,content=\"\"}\r\n      end\r\n      file.content = type(content)=='string' and content or file.content\r\n      return api.post(\"/quickApp/\"..(deviceId or MID)..\"/files\",file) \r\n    end\r\n\r\n    function fibaro.getFile(deviceId,file)\r\n      local name = type(file)=='table' and file.name or file\r\n      return api.get(\"/quickApp/\"..(deviceId or MID)..\"/files/\"..name) \r\n    end\r\n\r\n    function fibaro.getFiles(deviceId)\r\n      local res,code = api.get(\"/quickApp/\"..(deviceId or MID)..\"/files\")\r\n      return res or {},code\r\n    end\r\n\r\n    function fibaro.copyFileFromTo(fileName,deviceFrom,deviceTo)\r\n      deviceTo = deviceTo or (deviceId or MID)\r\n      local copyFile = fibaro.getFile(deviceFrom,fileName)\r\n      assert(copyFile,\"File doesn't exists\")\r\n      fibaro.addFileTo(copyFile.content,fileName,deviceTo)\r\n    end\r\n\r\n    function fibaro.addFileTo(fileContent,fileName,deviceId)\r\n      deviceId = deviceId or MID\r\n      local file = fibaro.getFile(deviceId,fileName)\r\n      if not file then\r\n        local stat,res = fibaro.createFile(deviceId,{   -- Create new file\r\n            name=fileName,\r\n            type=\"lua\",\r\n            isMain=false,\r\n            isOpen=false,\r\n            content=fileContent\r\n          })\r\n        if res == 200 then\r\n          fibaro.debug(nil,\"File '\",fileName,\"' added\")\r\n        else self:error(\"Error:\",res) end\r\n      elseif file.content ~= fileContent then\r\n        local stat,res = fibaro.updateFile(deviceId,{   -- Update existing file\r\n            name=file.name,\r\n            type=\"lua\",\r\n            isMain=file.isMain,\r\n            isOpen=file.isOpen,\r\n            content=fileContent\r\n          })\r\n        if res == 200 then\r\n          fibaro.debug(nil,\"File '\",fileName,\"' updated\")\r\n        else fibaro.error(nil,\"Error:\",res) end\r\n      else\r\n        fibaro.debug(nil,\"File '\",fileName,\"' not changed\")\r\n      end\r\n    end\r\n\r\n    function fibaro.getFQA(deviceId) return api.get(\"/quickApp/export/\"..deviceId) end\r\n\r\n    function fibaro.putFQA(content) -- Should be .fqa json\r\n      if type(content)=='table' then content = json.encode(content) end\r\n      return api.post(\"/quickApp/\",content)\r\n    end\r\n\r\n-- Add interfaces to QA. Note, if interfaces are added the QA will restart\r\n    local _addInterf = QuickApp.addInterfaces\r\n    function QuickApp:addInterfaces(interfaces) \r\n      local d,map = __fibaro_get_device(self.id),{}\r\n      for _,i in ipairs(d.interfaces or {}) do map[i]=true end\r\n      for _,i in ipairs(interfaces or {}) do\r\n        if not map[i] then\r\n          _addInterf(self,interfaces)\r\n          return\r\n        end\r\n      end\r\n    end\r\n\r\n    local _updateProperty = QuickApp.updateProperty\r\n    function QuickApp:updateProperty(prop,value)\r\n      local _props = self.properties\r\n      if _props==nil or _props[prop] ~= nil then\r\n        return _updateProperty(self,prop,value)\r\n      elseif debugFlags.propWarn then self:warningf(\"Trying to update non-existing property - %s\",prop) end\r\n    end\r\n  end\r\n\r\n  function QuickApp:setChildIconPath(childId,path)\r\n    api.put(\"/devices/\"..childId,{properties={icon={path=path}}})\r\n  end\r\n\r\n--Ex. self:callChildren(\"method\",1,2) will call MyClass:method(1,2) \r\n  function QuickApp:callChildren(method,...)\r\n    for _,child in pairs(self.childDevices or {}) do \r\n      if child[method] then \r\n        local stat,res = pcall(child[method],child,...)  \r\n        if not stat then self:debug(res,2) end\r\n      end\r\n    end\r\n  end\r\n\r\n  function QuickApp:removeAllChildren()\r\n    for id,_ in pairs(self.childDevices or {}) do self:removeChildDevice(id) end\r\n  end\r\n\r\n  function QuickApp:numberOfChildren()\r\n    local n = 0\r\n    for _,_ in pairs(self.childDevices or {}) do n=n+1 end\r\n    return n\r\n  end\r\n\r\n  function QuickApp:getChildVariable(child,varName) \r\n    for _,v in ipairs(child.properties.quickAppVariables or {}) do\r\n      if v.name==varName then return v.value end\r\n    end\r\n    return \"\"\r\n  end\r\n\r\n  local function annotateClass(self,classObj)\r\n    if not classObj then return end\r\n    local stat,res = pcall(function() return classObj._annotated end) \r\n    if stat and res then return end\r\n    --self:debug(\"Annotating class\")\r\n    for _,m in ipairs({\r\n        \"notify\",\"setVisible\",\"setEnabled\",\"setIconMessage\",\"setName\",\"getView\",\"updateProperty\",\r\n        \"setView\",\"debug\",\"trace\",\"error\",\"warning\",\"debugf\",\"tracef\",\"errorf\",\"warningf\"}) \r\n    do classObj[m] = self[m] end\r\n    classObj.debugFlags = self.debugFlags\r\n  end\r\n\r\n  local function setCallbacks(obj,callbacks)\r\n    if callbacks ==\"\" then return end\r\n    local cbs = {}\r\n    for _,cb in ipairs(callbacks or {}) do\r\n      cbs[cb.name]=cbs[cb.name] or {}\r\n      cbs[cb.name][cb.eventType] = cb.callback\r\n    end\r\n    obj.uiCallbacks = cbs\r\n  end\r\n\r\n--[[\r\n  QuickApp:createChild{\r\n    className = \"MyChildDevice\",      -- class name of child object\r\n    name = \"MyName\",                  -- Name of child device\r\n    type = \"com.fibaro.binarySwitch\", -- Type of child device\r\n    properties = {},                  -- Initial properties\r\n    interfaces = {},                  -- Initial interfaces\r\n  }\r\n--]]\r\n  function QuickApp:createChild(args)\r\n    local className = args.className or \"QuickAppChild\"\r\n    annotateClass(self,_G[className])\r\n    local name = args.name or \"Child\"\r\n    local tpe = args.type or \"com.fibaro.binarySensor\"\r\n    local properties = args.properties or {}\r\n    local interfaces = args.interfaces or {}\r\n    properties.quickAppVariables = properties.quickAppVariables or {}\r\n    local function addVar(n,v) table.insert(properties.quickAppVariables,1,{name=n,value=v}) end\r\n    for n,v in pairs(args.quickVars or {}) do addVar(n,v) end\r\n    local callbacks = properties.uiCallbacks\r\n    if  callbacks then \r\n      local function copy(t) local r={}; for k,v in pairs(t) do r[k]=v end return r end\r\n      callbacks = copy(callbacks)\r\n      addVar('_callbacks',callbacks)\r\n    end\r\n    -- Save class name so we know when we load it next time\r\n    addVar('className',className) -- Add first\r\n    local child = self:createChildDevice({\r\n        name = name,\r\n        type=tpe,\r\n        initialProperties = properties,\r\n        initialInterfaces = interfaces\r\n      },\r\n      _G[className] -- Fetch class constructor from class name\r\n    )\r\n    if callbacks then setCallbacks(child,callbacks) end\r\n    return child\r\n  end\r\n\r\n-- Loads all children, called automatically at startup\r\n  function QuickApp:loadChildren()\r\n    local cdevs,n = api.get(\"/devices?parentId=\"..self.id) or {},0 -- Pick up all my children\r\n    function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\r\n    for _,child in ipairs(cdevs or {}) do\r\n      if not self.childDevices[child.id] then\r\n        local className = self:getChildVariable(child,\"className\")\r\n        local callbacks = self:getChildVariable(child,\"_callbacks\")\r\n        annotateClass(self,_G[className])\r\n        local childObject = _G[className] and _G[className](child) or QuickAppChild(child)\r\n        self.childDevices[child.id]=childObject\r\n        childObject.parent = self\r\n        setCallbacks(childObject,callbacks)\r\n      end\r\n      n=n+1\r\n    end\r\n    return n\r\n  end\r\n\r\n  local orgRemoveChildDevice = QuickApp.removeChildDevice\r\n  local childRemovedHook\r\n  function QuickApp:removeChildDevice(id)\r\n    if childRemovedHook then\r\n      pcall(childRemovedHook,id)\r\n    end\r\n    return orgRemoveChildDevice(self,id)\r\n  end\r\n  function QuickApp:setChildRemovedHook(fun) childRemovedHook=fun end\r\n\r\n-- UI handler to pass button clicks to children\r\n  function QuickApp:UIHandler(event)\r\n    local obj = self\r\n    if self.id ~= event.deviceId then obj = (self.childDevices or {})[event.deviceId] end\r\n    if not obj then return end\r\n    local elm,etyp = event.elementName, event.eventType\r\n    local cb = obj.uiCallbacks or {}\r\n    if obj[elm] then return obj:callAction(elm, event) end\r\n    if cb[elm] and cb[elm][etyp] and obj[cb[elm][etyp]] then return obj:callAction(cb[elm][etyp], event) end\r\n    if obj[elm..\"Clicked\"] then return obj:callAction(elm..\"Clicked\", event) end\r\n    self:warning(\"UI callback for element:\", elm, \" not found.\")\r\n  end\r\n\r\nend -- QA\r\n\r\n--------------------- Misc -----------------------------------------------------\r\ndo \r\n  function urlencode(str) -- very useful\r\n    if str then\r\n      str = str:gsub(\"\\n\", \"\\r\\n\")\r\n      str = str:gsub(\"([^%w %-%_%.%~])\", function(c)\r\n          return (\"%%%02X\"):format(string.byte(c))\r\n        end)\r\n      str = str:gsub(\" \", \"%%20\")\r\n    end\r\n    return str\t\r\n  end\r\n\r\n  json = json or {}\r\n  local setinterval,encode,decode =  -- gives us a better error messages\r\n  setInterval, json.encode, json.decode\r\n  local oldClearTimout,oldSetTimout\r\n\r\n  if not hc3_emulator then -- Patch short-sighthed setTimeout...\r\n    local function timer2str(t)\r\n      return format(\"[Timer:%d%s %s]\",t.n,t.log or \"\",os.date('%T %D',t.expires or 0))\r\n    end\r\n    local N = 0\r\n    local function isTimer(timer) return type(timer)=='table' and timer['%TIMER%'] end\r\n    local function makeTimer(ref,log,exp) N=N+1 return {['%TIMER%']=(ref or 0),n=N,log=log and \" (\"..log..\")\",expires=exp or 0,__tostring=timer2str} end\r\n    local function updateTimer(timer,ref) timer['%TIMER%']=ref end\r\n    local function getTimer(timer) return timer['%TIMER%'] end\r\n\r\n    clearTimeout,oldClearTimout=function(ref)\r\n      if isTimer(ref) then ref=getTimer(ref)\r\n        oldClearTimout(ref)\r\n      end\r\n    end,clearTimeout\r\n\r\n    setTimeout,oldSetTimout=function(f,ms,log)\r\n      local ref,maxt=makeTimer(nil,log,math.floor(os.time()+ms/1000+0.5)),2147483648-1\r\n      local fun = function() -- wrap function to get error messages\r\n        if debugFlags.lateTimer then\r\n          local d = os.time() - ref.expires\r\n          if d > debugFlags.lateTimer then fibaro.warningf(nil,\"Late timer (%ds):%s\",d,ref) end\r\n        end\r\n        local stat,res = pcall(f)\r\n        if not stat then \r\n          fibaro.error(nil,res)\r\n        end\r\n      end\r\n      if ms > maxt then\r\n        updateTimer(ref,oldSetTimout(function() updateTimer(ref,getTimer(setTimeout(fun,ms-maxt))) end,maxt))\r\n      else updateTimer(ref,oldSetTimout(fun,math.floor(ms+0.5))) end\r\n      return ref\r\n    end,setTimeout\r\n\r\n    function setInterval(fun,ms) -- can't manage looong intervals\r\n      return setinterval(function()\r\n          local stat,res = pcall(fun)\r\n          if not stat then \r\n            fibaro.error(nil,res)\r\n          end\r\n        end,math.floor(ms+0.5))\r\n    end\r\n\r\n    function json.decode(...)\r\n      local stat,res = pcall(decode,...)\r\n      if not stat then error(res,2) else return res end\r\n    end\r\n    function json.encode(...)\r\n      local stat,res = pcall(encode,...)\r\n      if not stat then error(res,2) else return res end\r\n    end\r\n  end\r\n\r\n  local httpClient = net.HTTPClient -- protect success/error with pcall and print error\r\n  function net.HTTPClient(args)\r\n    local http = httpClient()\r\n    return {\r\n      request = function(self,url,opts)\r\n        opts = copy(opts)\r\n        local success,err = opts.success,opts.error\r\n        if opts then\r\n          opts.timeout = opts.timeout or args and args.timeout\r\n        end\r\n        if success then \r\n          opts.success=function(res) \r\n            local stat,r=pcall(success,res)\r\n            if not stat then quickApp:error(r) end\r\n          end \r\n        end\r\n        if err then \r\n          opts.error=function(res) \r\n            local stat,r=pcall(err,res)\r\n            if not stat then quickApp:error(r) end\r\n          end \r\n        end\r\n        return http:request(url,opts)\r\n      end\r\n    }\r\n  end\r\n\r\n  do\r\n    local sortKeys = {\"type\",\"device\",\"deviceID\",\"value\",\"oldValue\",\"val\",\"key\",\"arg\",\"event\",\"events\",\"msg\",\"res\"}\r\n    local sortOrder={}\r\n    for i,s in ipairs(sortKeys) do sortOrder[s]=\"\\n\"..string.char(i+64)..\" \"..s end\r\n    local function keyCompare(a,b)\r\n      local av,bv = sortOrder[a] or a, sortOrder[b] or b\r\n      return av < bv\r\n    end\r\n\r\n    -- our own json encode, as we don't have 'pure' json structs, and sorts keys in order (i.e. \"stable\" output)\r\n    local function prettyJsonFlat(e) \r\n      local res,seen = {},{}\r\n      local function pretty(e)\r\n        local t = type(e)\r\n        if t == 'string' then res[#res+1] = '\"' res[#res+1] = e res[#res+1] = '\"'\r\n        elseif t == 'number' then res[#res+1] = e\r\n        elseif t == 'boolean' or t == 'function' or t=='thread' or t=='userdata' then res[#res+1] = tostring(e)\r\n        elseif t == 'table' then\r\n          if next(e)==nil then res[#res+1]='{}'\r\n          elseif seen[e] then res[#res+1]=\"..rec..\"\r\n          elseif e[1] or #e>0 then\r\n            seen[e]=true\r\n            res[#res+1] = \"[\" pretty(e[1])\r\n            for i=2,#e do res[#res+1] = \",\" pretty(e[i]) end\r\n            res[#res+1] = \"]\"\r\n          else\r\n            seen[e]=true\r\n            if e._var_  then res[#res+1] = format('\"%s\"',e._str) return end\r\n            local k = {} for key,_ in pairs(e) do k[#k+1] = key end\r\n            table.sort(k,keyCompare)\r\n            if #k == 0 then res[#res+1] = \"[]\" return end\r\n            res[#res+1] = '{'; res[#res+1] = '\"' res[#res+1] = k[1]; res[#res+1] = '\":' t = k[1] pretty(e[t])\r\n            for i=2,#k do\r\n              res[#res+1] = ',\"' res[#res+1] = k[i]; res[#res+1] = '\":' t = k[i] pretty(e[t])\r\n            end\r\n            res[#res+1] = '}'\r\n          end\r\n        elseif e == nil then res[#res+1]='null'\r\n        else error(\"bad json expr:\"..tostring(e)) end\r\n      end\r\n      pretty(e)\r\n      return table.concat(res)\r\n    end\r\n    json.encodeFast = prettyJsonFlat\r\n  end\r\n\r\n  do -- Used for print device table structs - sortorder for device structs\r\n    local sortKeys = {\r\n      'id','name','roomID','type','baseType','enabled','visible','isPlugin','parentId','viewXml','configXml',\r\n      'interfaces','properties','view', 'actions','created','modified','sortOrder'\r\n    }\r\n    local sortOrder={}\r\n    for i,s in ipairs(sortKeys) do sortOrder[s]=\"\\n\"..string.char(i+64)..\" \"..s end\r\n    local function keyCompare(a,b)\r\n      local av,bv = sortOrder[a] or a, sortOrder[b] or b\r\n      return av < bv\r\n    end\r\n\r\n    local function prettyJsonStruct(t0)\r\n      local res = {}\r\n      local function isArray(t) return type(t)=='table' and t[1] end\r\n      local function isEmpty(t) return type(t)=='table' and next(t)==nil end\r\n      local function printf(tab,fmt,...) res[#res+1] = string.rep(' ',tab)..format(fmt,...) end\r\n      local function pretty(tab,t,key)\r\n        if type(t)=='table' then\r\n          if isEmpty(t) then printf(0,\"[]\") return end\r\n          if isArray(t) then\r\n            printf(key and tab or 0,\"[\\n\")\r\n            for i,k in ipairs(t) do\r\n              local _ = pretty(tab+1,k,true)\r\n              if i ~= #t then printf(0,',') end\r\n              printf(tab+1,'\\n')\r\n            end\r\n            printf(tab,\"]\")\r\n            return true\r\n          end\r\n          local r = {}\r\n          for k,_ in pairs(t) do r[#r+1]=k end\r\n          table.sort(r,keyCompare)\r\n          printf(key and tab or 0,\"{\\n\")\r\n          for i,k in ipairs(r) do\r\n            printf(tab+1,'\"%s\":',k)\r\n            local _ =  pretty(tab+1,t[k])\r\n            if i ~= #r then printf(0,',') end\r\n            printf(tab+1,'\\n')\r\n          end\r\n          printf(tab,\"}\")\r\n          return true\r\n        elseif type(t)=='number' then\r\n          printf(key and tab or 0,\"%s\",t)\r\n        elseif type(t)=='boolean' then\r\n          printf(key and tab or 0,\"%s\",t and 'true' or 'false')\r\n        elseif type(t)=='string' then\r\n          printf(key and tab or 0,'\"%s\"',t:gsub('(%\")','\\\\\"'))\r\n        end\r\n      end\r\n      pretty(0,t0,true)\r\n      return table.concat(res,\"\")\r\n    end\r\n    json.encodeFormated = prettyJsonStruct\r\n  end\r\n\r\n  function fibaro.sequence(...)\r\n    local args,i = {...},1\r\n    local function stepper()\r\n      if i <= #args then\r\n        local arg = args[i]\r\n        i=i+1\r\n        if type(arg)=='number' then \r\n          setTimeout(stepper,arg)\r\n        elseif type(arg)=='table' and type(arg[1])=='function' then\r\n          pcall(table.unpack(arg))\r\n          setTimeout(stepper,0)\r\n        end\r\n      end\r\n    end\r\n    setTimeout(stepper,0)\r\n  end\r\n\r\n  function fibaro.trueFor(time,test,action,delay)\r\n    delay = delay or 1000\r\n    local state = false\r\n    local  function loop()\r\n      if test() then\r\n        if state == false then\r\n          state=os.time()+time\r\n        elseif state == true then\r\n        elseif state <=  os.time() then\r\n          if action() then\r\n            state = os.time()+time\r\n          else\r\n            state = true \r\n          end\r\n        end\r\n      else\r\n        state=false\r\n      end\r\n      setTimeout(loop,delay)\r\n    end\r\n  end\r\n\r\nend -- Misc\r\n\r\n--------------------- Events --------------------------------------------------\r\ndo\r\n  local inited,initEvents,_RECIEVE_EVENT\r\n\r\n  function fibaro.postRemote(id,ev) if not inited then initEvents() end; return fibaro.postRemote(id,ev) end\r\n  function fibaro.post(ev,t) if not inited then initEvents() end; return fibaro.post(ev,t) end\r\n  function fibaro.cancel(ref) if not inited then initEvents() end; return fibaro.cancel(ref) end\r\n  function fibaro.event(ev,fun,doc) if not inited then initEvents() end; return fibaro.event(ev,fun,doc) end\r\n  function fibaro.removeEvent(pattern,fun) if not inited then initEvents() end; return fibaro.removeEvent(pattern,fun) end\r\n  function fibaro.HTTPEvent(args) if not inited then initEvents() end; return fibaro.HTTPEvent(args) end\r\n  function QuickApp:RECIEVE_EVENT(ev) if not inited then initEvents() end; return _RECIEVE_EVENT(self,ev) end\r\n  function fibaro.initEvents() if not inited then initEvents() end end\r\n\r\n  function initEvents()\r\n    local function DEBUG(...) if debugFlags.event then fibaro.debugf(nil,...) end end\r\n    DEBUG(\"Setting up events\")\r\n    inited = true \r\n\r\n    local em,handlers = { sections = {}, stats={tried=0,matched=0}},{}\r\n    em.BREAK, em.TIMER, em.RULE = '%%BREAK%%', '%%TIMER%%', '%%RULE%%'\r\n    local handleEvent,invokeHandler,post\r\n    local function isEvent(e) return type(e)=='table' and e.type end\r\n    local function isRule(e) return type(e)=='table' and e[em.RULE] end\r\n\r\n-- This can be used to \"post\" an event into this QA... Ex. fibaro.call(ID,'RECIEVE_EVENT',{type='myEvent'})\r\n    function _RECIEVE_EVENT(self,ev)\r\n      assert(isEvent(ev),\"Bad argument to remote event\")\r\n      local time = ev.ev._time\r\n      ev,ev.ev._time = ev.ev,nil\r\n      if time and time+5 < os.time() then fibaro.warningf(nil,\"Slow events %s, %ss\",ev,os.time()-time) end\r\n      fibaro.post(ev)\r\n    end\r\n\r\n    function fibaro.postRemote(id,ev)\r\n      assert(tonumber(id) and isEvent(ev),\"Bad argument to postRemote\")\r\n      ev._from,ev._time = MID,os.time()\r\n      fibaro.call(id,'RECIEVE_EVENT',{type='EVENT',ev=ev}) -- We need this as the system converts \"99\" to 99 and other \"helpful\" conversions\r\n    end\r\n\r\n    function fibaro.post(ev,t)\r\n      local now = os.time()\r\n      t = type(t)=='string' and toTime(t) or t or 0\r\n      if t < 0 then return elseif t < now then t = t+now end\r\n      if debugFlags.post and not ev._sh then fibaro.tracef(nil,\"Posting %s at %s\",ev,os.date(\"%c\",t)) end\r\n      if type(ev) == 'function' then\r\n        return setTimeout(ev,1000*(t-now))\r\n      else\r\n        return setTimeout(function() handleEvent(ev) end,1000*(t-now))\r\n      end\r\n    end\r\n\r\n-- Cancel post in the future\r\n    function fibaro.cancel(ref) clearTimeout(ref) end\r\n\r\n    local function transform(obj,tf)\r\n      if type(obj) == 'table' then\r\n        local res = {} for l,v in pairs(obj) do res[l] = transform(v,tf) end \r\n        return res\r\n      else return tf(obj) end\r\n    end\r\n    utils.transform = transform\r\n\r\n    local function coerce(x,y) local x1 = tonumber(x) if x1 then return x1,tonumber(y) else return x,y end end\r\n    local constraints = {}\r\n    constraints['=='] = function(val) return function(x) x,val=coerce(x,val) return x == val end end\r\n    constraints['<>'] = function(val) return function(x) return tostring(x):match(val) end end\r\n    constraints['>='] = function(val) return function(x) x,val=coerce(x,val) return x >= val end end\r\n    constraints['<='] = function(val) return function(x) x,val=coerce(x,val) return x <= val end end\r\n    constraints['>'] = function(val) return function(x) x,val=coerce(x,val) return x > val end end\r\n    constraints['<'] = function(val) return function(x) x,val=coerce(x,val) return x < val end end\r\n    constraints['~='] = function(val) return function(x) x,val=coerce(x,val) return x ~= val end end\r\n    constraints[''] = function(_) return function(x) return x ~= nil end end\r\n    em.coerce = coerce\r\n\r\n    local function compilePattern2(pattern)\r\n      if type(pattern) == 'table' then\r\n        if pattern._var_ then return end\r\n        for k,v in pairs(pattern) do\r\n          if type(v) == 'string' and v:sub(1,1) == '$' then\r\n            local var,op,val = v:match(\"$([%w_]*)([<>=~]*)(.*)\")\r\n            var = var ==\"\" and \"_\" or var\r\n            local c = constraints[op](tonumber(val) or val)\r\n            pattern[k] = {_var_=var, _constr=c, _str=v}\r\n          else compilePattern2(v) end\r\n        end\r\n      end\r\n      return pattern\r\n    end\r\n\r\n    local function compilePattern(pattern)\r\n      pattern = compilePattern2(copy(pattern))\r\n      if pattern.type and type(pattern.id)=='table' and not pattern.id._constr then\r\n        local m = {}; for _,id in ipairs(pattern.id) do m[id]=true end\r\n        pattern.id = {_var_='_', _constr=function(val) return m[val] end, _str=pattern.id}\r\n      end\r\n      return pattern\r\n    end\r\n    em.compilePattern = compilePattern\r\n\r\n    local function match(pattern, expr)\r\n      local matches = {}\r\n      local function unify(pattern,expr)\r\n        if pattern == expr then return true\r\n        elseif type(pattern) == 'table' then\r\n          if pattern._var_ then\r\n            local var, constr = pattern._var_, pattern._constr\r\n            if var == '_' then return constr(expr)\r\n            elseif matches[var] then return constr(expr) and unify(matches[var],expr) -- Hmm, equal?\r\n            else matches[var] = expr return constr(expr) end\r\n          end\r\n          if type(expr) ~= \"table\" then return false end\r\n          for k,v in pairs(pattern) do if not unify(v,expr[k]) then return false end end\r\n          return true\r\n        else return false end\r\n      end\r\n      return unify(pattern,expr) and matches or false\r\n    end\r\n    em.match = match\r\n\r\n    function invokeHandler(env)\r\n      local t = os.time()\r\n      env.last,env.rule.time = t-(env.rule.time or 0),t\r\n      local status, res = pcall(env.rule.action,env) -- call the associated action\r\n      if not status then\r\n        fibaro.errorf(nil,\"in %s: %s\",env.rule.doc,res)\r\n        env.rule._disabled = true -- disable rule to not generate more errors\r\n      else return res end\r\n    end\r\n\r\n    local toHash,fromHash={},{}\r\n    fromHash['device'] = function(e) return {\"device\"..e.id..e.property,\"device\"..e.id,\"device\"..e.property,\"device\"} end\r\n    fromHash['global-variable'] = function(e) return {'global-variable'..e.name,'global-variable'} end\r\n    fromHash['quickvar'] = function(e) return {\"quickvar\"..e.id..e.name,\"quickvar\"..e.id,\"quickvar\"..e.name,\"quickvar\"} end\r\n    fromHash['profile'] = function(e) return {'profile'..e.property,'profile'} end\r\n    fromHash['weather'] = function(e) return {'weather'..e.property,'weather'} end\r\n    fromHash['custom-event'] = function(e) return {'custom-event'..e.name,'custom-event'} end\r\n    fromHash['deviceEvent'] = function(e) return {\"deviceEvent\"..e.id..e.value,\"deviceEvent\"..e.id,\"deviceEvent\"..e.value,\"deviceEvent\"} end\r\n    fromHash['sceneEvent'] = function(e) return {\"sceneEvent\"..e.id..e.value,\"sceneEvent\"..e.id,\"sceneEvent\"..e.value,\"sceneEvent\"} end\r\n    toHash['device'] = function(e) return \"device\"..(e.id or \"\")..(e.property or \"\") end   \r\n    toHash['global-variable'] = function(e) return 'global-variable'..(e.name or \"\") end\r\n    toHash['quickvar'] = function(e) return 'quickvar'..(e.id or \"\")..(e.name or \"\") end\r\n    toHash['profile'] = function(e) return 'profile'..(e.property or \"\") end\r\n    toHash['weather'] = function(e) return 'weather'..(e.property or \"\") end\r\n    toHash['custom-event'] = function(e) return 'custom-event'..(e.name or \"\") end\r\n    toHash['deviceEvent'] = function(e) return 'deviceEvent'..(e.id or \"\")..(e.value or \"\") end\r\n    toHash['sceneEvent'] = function(e) return 'sceneEvent'..(e.id or \"\")..(e.value or \"\") end\r\n\r\n    if not table.maxn then \r\n      function table.maxn(tbl)local c=0; for _ in pairs(tbl) do c=c+1 end return c end\r\n    end\r\n\r\n    local function rule2str(rule) return rule.doc end\r\n    local function comboToStr(r)\r\n      local res = { r.src }\r\n      for _,s in ipairs(r.subs) do res[#res+1]=\"   \"..tostring(s) end\r\n      return table.concat(res,\"\\n\")\r\n    end\r\n    function map(f,l,s) s = s or 1; local r={} for i=s,table.maxn(l) do r[#r+1] = f(l[i]) end return r end\r\n    function mapF(f,l,s) s = s or 1; local e=true for i=s,table.maxn(l) do e = f(l[i]) end return e end\r\n\r\n    local function comboEvent(e,action,rl,doc)\r\n      local rm = {[em.RULE]=e, action=action, doc=doc, subs=rl}\r\n      rm.enable = function() mapF(function(e) e.enable() end,rl) return rm end\r\n      rm.disable = function() mapF(function(e) e.disable() end,rl) return rm end\r\n      rm.start = function(event) invokeHandler({rule=rm,event=event}) return rm end\r\n      rm.__tostring = comboToStr\r\n      return rm\r\n    end\r\n\r\n    function fibaro.event(pattern,fun,doc)\r\n      doc = doc or format(\"Event(%s) => ..\",json.encode(pattern))\r\n      if type(pattern) == 'table' and pattern[1] then \r\n        return comboEvent(pattern,fun,map(function(es) return fibaro.event(es,fun) end,pattern),doc) \r\n      end\r\n      if isEvent(pattern) then\r\n        if pattern.type=='device' and pattern.id and type(pattern.id)=='table' then\r\n          return fibaro.event(map(function(id) local e1 = copy(pattern); e1.id=id return e1 end,pattern.id),fun,doc)\r\n        end\r\n      else error(\"Bad event pattern, needs .type field\") end\r\n      assert(type(fun)=='function',\"Second argument must be Lua function\")\r\n      local cpattern = compilePattern(pattern)\r\n      local hashKey = toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type\r\n      handlers[hashKey] = handlers[hashKey] or {}\r\n      local rules = handlers[hashKey]\r\n      local rule,fn = {[em.RULE]=cpattern, event=pattern, action=fun, doc=doc}, true\r\n      for _,rs in ipairs(rules) do -- Collect handlers with identical patterns. {{e1,e2,e3},{e1,e2,e3}}\r\n        if equal(cpattern,rs[1].event) then \r\n          rs[#rs+1] = rule\r\n          fn = false break \r\n        end\r\n      end\r\n      if fn then rules[#rules+1] = {rule} end\r\n      rule.enable = function() rule._disabled = nil return rule end\r\n      rule.disable = function() rule._disabled = true return rule end\r\n      rule.start = function(event) invokeHandler({rule=rule, event=event, p={}}) return rule end\r\n      rule.__tostring = rule2str\r\n      if em.SECTION then\r\n        local s = em.sections[em.SECTION] or {}\r\n        s[#s+1] = rule\r\n        em.sections[em.SECTION] = s\r\n      end\r\n      return rule\r\n    end\r\n\r\n    function fibaro.removeEvent(pattern,fun)\r\n      local hashKey = toHash[pattern.type] and toHash[pattern.type](pattern) or pattern.type\r\n      local rules,i,j= handlers[hashKey] or {},1,1\r\n      while j <= #rules do\r\n        local rs = rules[j]\r\n        while i <= #rs do\r\n          if rs[i].action==fun then\r\n            table.remove(rs,i)\r\n          else i=i+i end\r\n        end\r\n        if #rs==0 then table.remove(rules,j) else j=j+1 end\r\n      end\r\n    end\r\n\r\n    function handleEvent(ev)\r\n      local hasKeys = fromHash[ev.type] and fromHash[ev.type](ev) or {ev.type}\r\n      for _,hashKey in ipairs(hasKeys) do\r\n        for _,rules in ipairs(handlers[hashKey] or {}) do -- Check all rules of 'type'\r\n          local i,m=1,nil\r\n          em.stats.tried=em.stats.tried+1\r\n          for i=1,#rules do\r\n            if not rules[i]._disabled then    -- find first enabled rule, among rules with same head\r\n              m = match(rules[i][em.RULE],ev) -- and match against that rule\r\n              break\r\n            end\r\n          end\r\n          if m then                           -- we have a match\r\n            for i=i,#rules do                 -- executes all rules with same head\r\n              local rule=rules[i]\r\n              if not rule._disabled then \r\n                em.stats.matched=em.stats.matched+1\r\n                if invokeHandler({event = ev, p=m, rule=rule}) == em.BREAK then return end\r\n              end\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    local function handlerEnable(t,handle)\r\n      if type(handle) == 'string' then utils.mapf(em[t],em.sections[handle] or {})\r\n      elseif isRule(handle) then handle[t]()\r\n      elseif type(handle) == 'table' then utils.mapf(em[t],handle) \r\n      else error('Not an event handler') end\r\n      return true\r\n    end\r\n\r\n    function em.enable(handle,opt)\r\n      if type(handle)=='string' and opt then \r\n        for s,e in pairs(em.sections or {}) do \r\n          if s ~= handle then handlerEnable('disable',e) end\r\n        end\r\n      end\r\n      return handlerEnable('enable',handle) \r\n    end\r\n    function em.disable(handle) return handlerEnable('disable',handle) end\r\n\r\n--[[\r\n  Event.http{url=\"foo\",tag=\"55\",\r\n    headers={},\r\n    timeout=60,\r\n    basicAuthorization = {user=\"admin\",password=\"admin\"}\r\n    checkCertificate=0,\r\n    method=\"GET\"}\r\n--]]\r\n\r\n    function fibaro.HTTPEvent(args)\r\n      local options,url = {},args.url\r\n      options.headers = args.headers or {}\r\n      options.timeout = args.timeout\r\n      options.method = args.method or \"GET\"\r\n      options.data = args.data or options.data\r\n      options.checkCertificate=options.checkCertificate\r\n      if args.basicAuthorization then \r\n        options.headers['Authorization'] = \r\n        utils.basicAuthorization(args.basicAuthorization.user,args.basicAuthorization.password)\r\n      end\r\n      if args.accept then options.headers['Accept'] = args.accept end\r\n      net.HTTPClient():request(url,{\r\n          options = options,\r\n          success=function(resp)\r\n            post({type='HTTPEvent',status=resp.status,data=resp.data,headers=resp.headers,tag=args.tag})\r\n          end,\r\n          error=function(resp)\r\n            post({type='HTTPEvent',result=resp,tag=args.tag})\r\n          end\r\n        })\r\n    end\r\n\r\n    em.isEvent,em.isRule,em.comboEvent = isEvent,isRule,comboEvent\r\n    fibaro.EM = em\r\n    fibaro.registerSourceTriggerCallback(handleEvent)\r\n\r\n  end -- initEvents\r\n\r\nend -- Events\r\n\r\n--------------------- PubSub ---------------------------------------------------\r\ndo\r\n  local SUB_VAR = \"TPUBSUB\"\r\n  local idSubs = {}\r\n  local function DEBUG(...) if debugFlags.pubsub then fibaro.debugf(nil,...) end end\r\n  local inited,initPubSub,match,compile\r\n\r\n  function fibaro.publish(event)\r\n    if not inited then initPubSub(quickApp) end\r\n    assert(type(event)=='table' and event.type,\"Not an event\")\r\n    local subs = idSubs[event.type] or {}\r\n    for _,e in ipairs(subs) do\r\n      if match(e.pattern,event) then\r\n        for id,_ in pairs(e.ids) do \r\n          DEBUG(\"Sending sub QA:%s\",id)\r\n          fibaro.call(id,\"SUBSCRIPTION\",event)\r\n        end\r\n      end\r\n    end\r\n  end\r\n\r\n  if QuickApp then -- only subscribe if we are an QuickApp. Scenes can publish\r\n    function fibaro.subscribe(events,handler)\r\n      if not inited then initPubSub(quickApp) end\r\n      if not events[1] then events = {events} end\r\n      local subs = quickApp:getVariable(SUB_VAR)\r\n      if subs == \"\" then subs = {} end\r\n      for _,e in ipairs(events) do\r\n        assert(type(e)=='table' and e.type,\"Not an event\")\r\n        if not member(e,subs) then subs[#subs+1]=e end\r\n      end\r\n      DEBUG(\"Setting subscription\")\r\n      quickApp:setVariable(SUB_VAR,subs)\r\n      if handler then\r\n        fibaro.event(events,handler)\r\n      end\r\n    end\r\n  end\r\n\r\n--  idSubs = {\r\n--    <type> = { { ids = {... }, event=..., pattern = ... }, ... }\r\n--  }\r\n\r\n  function initPubSub(self)\r\n    DEBUG(\"Setting up pub/sub\")\r\n    inited = true\r\n\r\n    fibaro.initEvents()\r\n\r\n    match = fibaro.EM.match\r\n    compile = fibaro.EM.compilePattern\r\n\r\n    function self:SUBSCRIPTION(e)\r\n      self:post(e)\r\n    end\r\n\r\n    local function updateSubscriber(id,events)\r\n      if not idSubs[id] then DEBUG(\"New subscriber, QA:%s\",id) end\r\n      for _,ev in ipairs(events) do\r\n        local subs = idSubs[ev.type] or {}\r\n        for _,s in ipairs(subs) do s.ids[id]=nil end\r\n      end\r\n      for _,ev in ipairs(events) do\r\n        local subs = idSubs[ev.type]\r\n        if subs == nil then\r\n          subs = {}\r\n          idSubs[ev.type]=subs\r\n        end\r\n        for _,e in ipairs(subs) do\r\n          if equal(ev,e.event) then\r\n            e.ids[id]=true\r\n            goto nxt\r\n          end\r\n        end\r\n        subs[#subs+1] = { ids={[id]=true}, event=copy(ev), pattern=compile(ev) }\r\n        ::nxt::\r\n      end\r\n    end\r\n\r\n    local function checkVars(id,vars)\r\n      for _,var in ipairs(vars or {}) do \r\n        if var.name==SUB_VAR then return updateSubscriber(id,var.value) end\r\n      end\r\n    end\r\n\r\n-- At startup, check all QAs for subscriptions\r\n    for _,d in ipairs(api.get(\"/devices?interface=quickApp\") or {}) do\r\n      checkVars(d.id,d.properties.quickAppVariables)\r\n    end\r\n\r\n    fibaro.event({type='quickvar',name=SUB_VAR},            -- If some QA changes subscription\r\n      function(env) \r\n        local id = env.event.id\r\n        DEBUG(\"QA:%s updated quickvar sub\",id)\r\n        updateSubscriber(id,env.event.value)       -- update\r\n      end) \r\n\r\n    fibaro.event({type='deviceEvent',value='removed'},      -- If some QA is removed\r\n      function(env) \r\n        local id = env.event.id\r\n        if id ~= self.id then\r\n          DEBUG(\"QA:%s removed\",id)\r\n          updateSubscriber(env.event.id,{})               -- update\r\n        end\r\n      end)\r\n\r\n    fibaro.event({\r\n        {type='deviceEvent',value='created'},              -- If some QA is added or modified\r\n        {type='deviceEvent',value='modified'}\r\n      },\r\n      function(env)                                             -- update\r\n        local id = env.event.id\r\n        if id ~= self.id then\r\n          DEBUG(\"QA:%s created/modified\",id)\r\n          checkVars(id,api.get(\"/devices/\"..id).properties.quickAppVariables)\r\n        end\r\n      end)\r\n  end\r\n\r\nend -- PubSub\r\n\r\n--------------------- HTTP stuff ----------------------------------------------\r\n-- How can we make it easier?\r\n----------------- Auto update stuff ---------------------------------------------\r\ndo\r\n  fibaro._URL_UPDATE_BASE = \"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/\"\r\n  fibaro._UPDATE_MANIFEST = \"VERSION4.json\"\r\n  fibaro._FIBAROEXTRA_NAME = \"fibaroExtra.lua\"\r\n\r\n  function fibaro.updateFibaroExtra(fname)\r\n    fname = fname or fibaro._FIBAROEXTRA_NAME or \"fibaroExtra.lua\"\r\n    local function fetch(url,cont)\r\n      --fibaro.debug(__TAG,\"Fetching \",url)\r\n      net.HTTPClient():request(url,{\r\n          options = {method = 'GET', checkCertificate = false, timeout=20000},\r\n          success = function(res) \r\n            if res.status == 200 then cont(res.data)\r\n            else fibaro.error(__TAG,\"Error \",res.status,\" fetching \",url) end\r\n          end,\r\n          error  = function(res) \r\n            fibaro.error(__TAG,\"Error \",res,\" fetching \",url)\r\n          end\r\n        })\r\n    end\r\n    local base = fibaro._URL_UPDATE_BASE or \"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/\"\r\n    local manifest = fibaro._UPDATE_MANIFEST or \"VERSION4.json\"\r\n    fetch(base..manifest,\r\n      function(manifest)\r\n        manifest = json.decode(manifest)\r\n        if fibaro.FIBARO_EXTRA == nil or manifest[fname] > fibaro.FIBARO_EXTRA then\r\n          fibaro.debug(__TAG,\"New version of \",fname)\r\n          fetch(fibaro._URL_UPDATE_BASE..fname,\r\n            function(code)\r\n              local name=fname:match(\"(.*)%.[Ll][Uu][Aa]\") or \"library\"\r\n              local f = {isMain=false,type='lua',isOpen=false,name=name,content=code}\r\n              if api.get(\"/quickApp/\"..plugin.mainDeviceId..\"/files/\"..name) then\r\n                fibaro.debug(__TAG,\"Updating \",name)\r\n                local _,res = api.put(\"/quickApp/\"..plugin.mainDeviceId..\"/files/\"..name,f)\r\n                if res ~= 200 then fibaro.error(___TAG,\"Updating \",name,\" - \",res) end\r\n              else\r\n                fibaro.debug(__TAG,\"Installing \",name)\r\n                local _,res = api.put(\"/quickApp/\"..plugin.mainDeviceId..\"/files\",f)\r\n                if res ~= 200 then fibaro.error(__TAG,\"Installing \",name,\" - \",res) end\r\n              end\r\n            end)\r\n        end\r\n      end)\r\n  end\r\n\r\n  function fibaro.installFibaroExtra()\r\n    local name = \"fibaroExtra\"\r\n    if fibaro.FIBARO_EXTRA then return end\r\n    local url = \"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/\"..name..\".lua\"\r\n    net.HTTPClient():request(url,{\r\n        options = {method = 'GET', checkCertificate = false, timeout=20000},\r\n        success = function(res) \r\n          if res.status == 200 then \r\n            local f = {isMain=false,type='lua',isOpen=false,name=name,content=res.data}\r\n            fibaro.debug(__TAG,\"Installing \",name)\r\n            local _,res = api.post(\"/quickApp/\"..plugin.mainDeviceId..\"/files\",f)\r\n            if res ~= 200 then fibaro.error(__TAG,\"Installing \",name,\" - \",res) end              \r\n          else fibaro.error(__TAG,\"Error \",res.status,\" fetching \",url) end\r\n        end,\r\n        error  = function(res) \r\n          fibaro.error(__TAG,\"Error \",res,\" fetching \",url)\r\n        end\r\n      })\r\n  end\r\n\r\n--[[ Mini installer\r\nfunction fibaro.installFibaroExtra()local a=\"fibaroExtra\"if fibaro.FIBARO_EXTRA then return end;local b=\"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/\"..a..\".lua\"net.HTTPClient():request(b,{options={method='GET',checkCertificate=false,timeout=20000},success=function(c)if c.status==200 then local d={isMain=false,type='lua',isOpen=false,name=a,content=c.data}fibaro.debug(__TAG,\"Installing \",a)local e,c=api.post(\"/quickApp/\"..plugin.mainDeviceId..\"/files\",d)if c~=200 then fibaro.error(__TAG,\"Installing \",a,\" - \",c)end else fibaro.error(__TAG,\"Error \",c.status,\" fetching \",b)end end,error=function(c)fibaro.error(__TAG,\"Error \",c,\" fetching \",b)end})end\r\n--]]\r\n--[[\r\nlocal fileList = {\r\n  {\r\n    file = \"main\"\r\n  },\r\n  {\r\n    file = \"fibaroExtra\", \r\n    url=\"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/fibaroExtra.lua\",\r\n    manifest=\"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/VERSION4.json\"\r\n  },\r\n}\r\ncheckForUpdate(fileList)\r\n--]]\r\n\r\nend -- Auto update"}]}