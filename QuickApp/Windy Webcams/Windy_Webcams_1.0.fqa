{"name":"Windy Webcams","type":"com.fibaro.genericDevice","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_1016"},"sections":{"items":[]}},"head":{"title":"quickApp_device_1016"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"distance","value":"0"},{"name":"apiKey","value":"0"},{"name":"locationId","value":"0"},{"name":"refreshInterval","value":"0"},{"name":"maxWebcam","value":"0"},{"name":"storedData","value":{}}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":false,"content":"--[[\n   Copyright [2021] [Julien Wetzel]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n]]\n\n-- Initialisation\nfunction QuickApp:onInit()\n\tself.config  = Config:new(self)\n\tself.auth    = Auth:new(self.config)\n\tself.http    = HTTPClient:new()\n\tself.install = Installation:new()\n\tself:trace('')\n\tself:trace('Windy Webcams')\n\tself:run()\nend\n\n-- run interval\nfunction QuickApp:run()\n\tself:installation(function() self:pullWindyData() end)\n\tlocal interval = self.config:getTimeoutInterval()\n\tif self:isEmpty(interval) then fibaro.setTimeout(1000*60*1, function() self:run() end)\n\telse fibaro.setTimeout(interval, function() self:run() end)\n\tend\nend\n\n-- Main function\nfunction QuickApp:pullWindyData()\n\tlocal location = self:getHCLocation(self.config:getLocationId())\n\tlocal url = string.format(\"https://api.windy.com/api/webcams/v2/list/orderby=popularity/nearby=%s,%s,%s/limit=%s?show=webcams:location,image\", location.lat, location.lon, self.config:getDistance(), self.config:getLimit())\n\tself:trace(\"Connecting:\", url)\n\n\t-- callback function\n\tlocal callback = function(response)\n\t\tlocal data = json.decode(response.data)\n\t\tlocal res = data.result\n\n\t\t-- If data are OK\n\t\tif data.status == \"OK\" then\n\t\t\tself:trace(\"Webcam found : \" .. tostring(res.total))\n\t\t\tself:trace(\"Webcam safe limitation : \" .. tostring(res.limit)) \n\t\t\tlocal storedData = self.config:getStoredData()\n\n\t\t\t-- Initialize storedData if empty\n\t\t\tif self:isEmpty(storedData.webcams) then \n\t\t\t\tself:setVariable(\"storedData\",{})\n\t\t\t\tstoredData[\"webcams\"] = {} \n\t\t\tend\n\n\t\t\tlocal webcam = {}\n\t\t\tlocal webcamConfig = self.config:getDeviceTemplate()\n\t\t\tlocal webcamExist = true\n\t\t\tlocal n,r,c,camInfo\n\n\t\t\t-- Webcam device creation\n\t\t\tfor _,v in pairs(res.webcams) do\n\t\t\t\twebcam = storedData.webcams[v.id]\n\n\t\t\t\t-- If webcam not exist\n\t\t\t\tif webcam == nil then webcam = {status = \"\", city = \"\", img = \"\", deviceId = \"\", inList = true} end\n\n\t\t\t\t-- True or false if device is in the HC3\n\t\t\t\twebcamExist, camInfo = self:ifDeviceExist( webcam.deviceId )\n\n\t\t\t\t-- Webcam inList on the request Windy server\n\t\t\t\twebcam.inList = true\n\n\t\t\t\t-- Webcam status process\n\t\t\t\tif self:isEmpty(v.status) == false then webcam.status = v.status\n\t\t\t\telse \n\t\t\t\t\treturn self:error(\"Not received Webcam status on Windy server\") \n\t\t\t\tend\n\n\t\t\t\t-- Webcam city process\n\t\t\t\tif self:isEmpty(v.location.city) == false then \n\t\t\t\t\twebcam.city   = v.location.city\n\t\t\t\telse \n\t\t\t\t\treturn self:error(\"Not received Webcam city on Windy server\") \n\t\t\t\tend\n\n\t\t\t\t-- Webcam name process\n\t\t\t\tif (webcam.name == \"\" or self:isEmpty(webcam.name)) then webcam.name = \"wy \" .. webcam.city\n\t\t\t\t\tif string.len(webcam.name) > 20 then webcam.name = string.sub(webcam.name,1,20) end\n\t\t\t\t\twebcamConfig.name = webcam.name\n\t\t\t\tend\n\n\t\t\t\t-- Link img process\n\t\t\t\tif self:isEmpty(v.image.current.preview) == false then\n\t\t\t\t\t_,n = string.find(v.image.current.preview,\".com\")\n\t\t\t\t\twebcam.img = string.sub(v.image.current.preview,n+1)\n\t\t\t\telse \n\t\t\t\t\treturn self:error(\"Not received link image on Windy server\")\n\t\t\t\tend\n\n\t\t\t\t-- Datas verification\n\t\t\t\tfor o,p in pairs(webcam) do\n\t\t\t\t\tif self:isEmpty(p) and o ~= \"deviceId\" then\n\t\t\t\t\t\treturn self:error(\"storedData new webcam, var \\\"\" .. o .. \"\\\" are not defined\")\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\twebcamConfig.properties.jpgPath = webcam.img\n\n\t\t\t\t-- Webcam visible and enabled\n\t\t\t\tif webcam.status ~= \"active\" then \n\t\t\t\t\twebcamConfig.enabled = false\n\t\t\t\t\twebcamConfig.visible = false\n\t\t\t\telse \n\t\t\t\t\twebcamConfig.enabled = true\n\t\t\t\t\twebcamConfig.visible = true \n\t\t\t\tend\n\n\t\t\t\t-- Add or update camera device \n\t\t\t\tif not(webcamExist) then\n\t\t\t\t\tr,c = api.post(\"/devices\", webcamConfig)\n\t\t\t\t\tif c ~= 200 then self:error(\"Camera \\\"\" .. webcam.name .. \"\\\" not created, error: \" .. c .. \" \" .. r.message)\n\t\t\t\t\telse webcam.deviceId = r.id \n\t\t\t\t\t\tself:trace(\"Webcam[id:\" .. r.id .. \"] \\\"\" .. webcam.name .. \"\\\" added\") \n\t\t\t\t\tend\n\t\t\t\telse \n\t\t\t\t\tr,c = api.put(\"/devices/\" .. webcam.deviceId, webcamConfig)\n\t\t\t\t\tif c ~= 200 then self:error(\"Camera \\\"\" .. camInfo.name .. \"\\\" not updated, error: \" .. c .. \" \" .. r.message) \n\t\t\t\t\telse self:trace(\"Webcam[id:\" .. r.id .. \"] \\\"\" .. camInfo.name .. \"\\\" updated\") end\n\t\t\t\tend\n\n\t\t\t\t-- Var deviceId verification\n\t\t\t\tif self:isEmpty(webcam.deviceId) then\n\t\t\t\t\treturn self:error(\"storedData, deviceId are not defined\")\n\t\t\t\tend\n\n\t\t\t\twebcam.inList = true\n\t\t\t\tstoredData.webcams[v.id] = webcam\n\t\t\tend\n\n\t\t\t-- Delete camera device\n\t\t\tif storedData.webcams ~= nil then\n\t\t\t\tfor a,j in pairs(storedData.webcams) do \n\t\t\t\t\tif j.inList == false then \n\t\t\t\t\t\tr,c = api.delete(\"/devices/\" .. j.deviceId)\n\t\t\t\t\t\tif c ~= 200 then \n\t\t\t\t\t\t\tself:error(\"Camera \\\"\" .. j.name .. \"\\\" not deleted, error: \" .. c .. \" \" .. r.message)\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tself:trace(\"Webcam[id:\" .. j.deviceId .. \"] \\\"\" .. j.name .. \"\\\" removed \") \n\t\t\t\t\t\t\tstoredData.webcams[a] = nil \n\t\t\t\t\t\tend\n\t\t\t\t\telse \n\t\t\t\t\t\tstoredData.webcams[a].inList = false \n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tself.config:setStoredData(storedData) \n\t\telse \n\t\t\treturn self:error(\"Webcam acquisition error\")\n\t\tend\n\tend\n\n\tself.http:get(url, callback, nil, self.auth:getHeaders({}))\n\treturn {}\nend\n\nfunction QuickApp:installation(nextFunction)\n\tlocal v = self:getVarInfo()\n\tlocal code = 0\n\tlocal ak = self.config:getApiKey()\n\tif ak  == \"0\" then code = 300\n\telse\n\t\tlocal url = \"https://api.windy.com/api/webcams/v2/list/limit=1?show=webcams:location\"\n\t\tlocal callback = function(response)\n\t\t\tif response.status == 200 then \n\t\t\t\tGlobals:set('windy_webcams_apikey', ak) \n\t\t\tend\n\t\t\tv.apiKey.code = response.status\n\t\t\tself.install:run(v,function() nextFunction() end)\n\t\tend\n\n\t\tself.http:get(url, callback, nil, self.auth:getHeaders({}))\n\t\treturn {}\n\tend\n\n\tv.apiKey.code = code\n\tself.install:run(v,function() nextFunction() end)\nend\n\nfunction QuickApp:getVarInfo()\n\tlocal varInfo = {\n\t\tdistance = {code = nil, unit = \"km\", example = \"5\", txt = \"\"}, \n\t\tapiKey = {code = nil, unit = \"\", example = \"MNgwCHC87gplxaH2z4VBeCUyvChDyXyS\", txt = \"\"},\n\t\tlocationId = {code = nil, unit = \"\", example = \"219\", txt = \"\"},\n\t\trefreshInterval = {code = nil, unit = \"min\", example = \"5\", txt = \"\"},\n\t\tmaxWebcam = {code = nil, unit = \"\", example = \"50\", txt = \"\"},\n\t}\n\tlocal c,r = 0\n\tr,c = self.config:getDistance()\n\tvarInfo.distance.code = c\n\tr,c = self.config:getLocationId()\n\tvarInfo.locationId.code = c\n\tr,c = self.config:getTimeoutInterval()\n\tvarInfo.refreshInterval.code = c\n\tr,c = self.config:getLimit()\n\tvarInfo.maxWebcam.code = c\n\n\tvarInfo.distance.txt = \"This is the search radius from the location.\"\n\n\tvarInfo.apiKey.txt = \"[Step 1] Create a login to <a target='_blank' href='https://community.windy.com/login'>https://community.windy.com/login</a>\"\n\tvarInfo.apiKey.txt = varInfo.apiKey.txt .. \"<br>[Step 2] Go to <a target='_blank' href='https://api.windy.com/keys'>https://api.windy.com/keys</a>\"\n\tvarInfo.apiKey.txt = varInfo.apiKey.txt .. \"<br>[Step 3] Click on button \\\"Create a new API Key\\\"\"\n\tvarInfo.apiKey.txt = varInfo.apiKey.txt .. \"<br>[Step 4] Fill the <b>Project identification</b> field (Example : \\\"Fibaro\\\")\"\n\tvarInfo.apiKey.txt = varInfo.apiKey.txt .. \"<br>[Step 5] Choose <b>Webcams API</b> option in API Service and click Create\"\n\tvarInfo.apiKey.txt = varInfo.apiKey.txt .. \"<br>[Step 6] Copy/past your ApiKey in the apiKey variable\"\n\n\tvarInfo.locationId.txt = \"Choose your ID location and set the variable \\\"locationId\\\"<br>\" .. self:tableLocation()\n\n\tvarInfo.refreshInterval.txt = \"This is the refresh rate in minutes.\"\n\tvarInfo.refreshInterval.txt = varInfo.refreshInterval.txt .. \"<br>- Please note that webcams are generally updated every 15 minutes.\"\n\n\tvarInfo.maxWebcam.txt = \"This is the limit of the maximum number of webcams that are retrieved.\"\n\tvarInfo.maxWebcam.txt = varInfo.maxWebcam.txt .. \"<br>It is possible to install the program several times to obtain webcams from several locations.\"\n\tvarInfo.maxWebcam.txt = varInfo.maxWebcam.txt .. \"<br>- Please note that it is not possible to get more than 50 webcams.\"\n\n\treturn varInfo\nend\n\n-- Get HC3 longitude and latitude\nfunction QuickApp:getHCLocation(val)\n\tlocal location,c = api.get(\"/panels/location/\" .. val)\n\tif c == 200 then \n\t\tself:trace(\"Configured name location:\", location.name)\n\t\tlocation = {lat = location.latitude, lon = location.longitude}\n\t\treturn location\n\telse return self:error(\"Error to get Location\")\n\tend\nend\n\nfunction QuickApp:isEmpty(s) return s == nil or s == \"\" end\n\n-- Return true or false if device exist\nfunction QuickApp:ifDeviceExist(id)\n\tif self:isEmpty(id) then \n\t\treturn false\n\telse \n\t\tlocal r,c = api.get(\"/devices/\" .. id)\n\t\tif c == 200 then return true, r\n\t\telse \n\t\t\treturn false, nil\n\t\tend\n\tend\nend\n\n-- Return list of location in HC3 in format web table\nfunction QuickApp:tableLocation()\n\tlocal list,_ = api.get(\"/panels/location\")\n\tlocal t = \"<tr><td>Location name</td><td>ID</td></tr>\"\n\tfor _,v in pairs(list) do t = t .. \"<tr><td>\" .. v.name .. \"</td><td>\" .. v.id .. \"</td></tr>\" end\n\treturn table(t,\"bgcolor='#203737' border='1' width=150px\")\nend"},{"name":"Config","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nclass 'Config'\r\n\r\nfunction Config:new(app)\r\n\tself.app = app\r\n\tself:init()\r\n\treturn self\r\nend\r\n\r\nfunction Config:getApiKey()\r\n\treturn self.apiKey\r\nend\r\n\r\nfunction Config:getDistance()\r\n\tlocal n = tonumber(self.distance )\r\n\tif n == 0 then return nil, 300\r\n\telseif n == nil then return nil, 303\r\n\telse return n, 200\r\n\tend\r\nend\r\n\r\nfunction Config:getLocationId()\r\n\tlocal n = tonumber(self.locationId)\r\n\tlocal _,c = api.get(\"/panels/location/\" .. n)\r\n\tif n == 0 then return nil, 300\r\n\telseif n == nil then return nil, 303\r\n\telseif c == 200 then return n, 200\r\n\telse return nil, 404\r\n\tend\r\nend\r\n\r\nfunction Config:getLimit() \r\n\tlocal n = tonumber(self.limit)\r\n\tif n == 0 then return nil, 300 \r\n\telseif n == nil then return nil, 303\r\n\telseif n < 0 or n > 50 then return nil, 303\r\n\telse return n, 200\r\n\tend\r\nend\r\n\r\nfunction Config:getTimeoutInterval()\r\n\tlocal n = tonumber(self.interval)\r\n\tif n  == 0 then return nil, 300\r\n\telseif n == nil then return nil, 303\r\n\telse return n * 60000, 200 \r\n\tend\r\nend\r\n\r\nfunction Config:getStoredData() return self.storedData end\r\nfunction Config:setStoredData(v) self.app:setVariable('storedData', v) end\r\nfunction Config:getDeviceTemplate() return self.deviceTemplate end\r\n\r\nfunction Config:init()\r\n\tself.locationId = self.app:getVariable('locationId')\r\n\tself.storedData = self.app:getVariable('storedData')\r\n\tself.apiKey     = self.app:getVariable('apiKey') \r\n\tself.distance   = self.app:getVariable('distance')\r\n\tself.interval   = self.app:getVariable('refreshInterval')\r\n\tself.limit      = self.app:getVariable('maxWebcam')\r\n\tself.deviceTemplate = {\r\n\t\ttype = \"com.fibaro.ipCamera\",\r\n\t\tbaseType = \"com.fibaro.camera\",\r\n\t\tenabled = true,\r\n\t\tvisible = true,\r\n\t\tproperties = {\r\n\t\t\thttpsEnabled = true,\r\n\t\t\tip = \"images-webcams.windy.com\",\r\n\t\t\tjpgPath = \"path\",\r\n\t\t\trefreshTime = 3600\r\n\t\t}}\r\n    \r\n\tlocal storedApiKey = Globals:get('windy_webcams_apikey')\r\n\tlocal storedInterval = Globals:get('windy_webcams_interval')\r\n\r\n\t-- handling apiKey\r\n\tif (QuickApp:isEmpty(self.apiKey) or self.apiKey == \"0\")\r\n    and not(QuickApp:isEmpty(storedApiKey)) then\r\n\t\tself.app:setVariable(\"apiKey\", storedApiKey) \r\n\t\tself.apiKey = storedApiKey\r\n\tend\r\n\r\n\t-- handling interval\r\n\tif not self.interval or self.interval == \"\" then\r\n\t\tif storedInterval and storedInterval ~= \"\" then\r\n\t\t\tself.app:setVariable(\"Refresh Interval\", storedInterval)\r\n\t\t\tself.interval = storedInterval\r\n\t\telse self.interval = \"5\" end\r\n\tend\r\n\tif (storedInterval == \"\" and self.interval ~= \"\") then\r\n\t\tGlobals:set('windy_webcams_interval', self.interval) end\r\n\tend"},{"name":"HTTPClient","isMain":false,"isOpen":false,"content":"--[[\r\nHTTPClient wrapper\r\n@author ikubicki\r\n\r\nMIT License\r\n\r\nCopyright (c) 2020 Irek Kubicki\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n]]\r\n    \r\nclass 'HTTPClient'\r\n\r\nfunction HTTPClient:new(options)\r\n    if not options then\r\n        options = {}\r\n    end\r\n    self.options = options\r\n    return self\r\nend\r\n\r\nfunction HTTPClient:get(url, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'GET', nil, headers)) \r\nend\r\n\r\nfunction HTTPClient:post(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'POST', data, headers)) \r\nend\r\n\r\nfunction HTTPClient:postForm(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    headers[\"Content-Type\"] = 'application/x-www-form-urlencoded;charset=UTF-8'\r\n    client:request(self:url(url), self:requestOptions(success, error, 'POST', data, headers, true)) \r\nend\r\n\r\nfunction HTTPClient:put(url, data, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    client:request(self:url(url), self:requestOptions(success, error, 'PUT', data, headers)) \r\nend\r\n\r\nfunction HTTPClient:delete(url, success, error, headers)\r\n    local client = net.HTTPClient({timeout = 10000})\r\n    if not headers then\r\n        headers = {}\r\n    end\r\n    client:request(self:url(url), self:requestOptions(success, error, 'DELETE', nil, headers)) \r\nend\r\n\r\nfunction HTTPClient:url(url)\r\n    if (string.sub(url, 0, 4) == 'http') then\r\n        return url\r\n    end\r\n    if not self.options.baseUrl then\r\n        self.options.baseUrl = 'http://localhost'\r\n    end\r\n    return self.options.baseUrl .. tostring(url)\r\nend\r\n\r\nfunction HTTPClient:requestOptions(success, error, method, data, headers, isFormData)\r\n    if error == nil then\r\n        error = function (error)\r\n            QuickApp:error(json.encode(error))\r\n        end\r\n    end\r\n    if method == nil then\r\n        method = 'GET'\r\n    end\r\n    local options = {\r\n        checkCertificate = false,\r\n        method = method,\r\n        headers = headers,\r\n    }\r\n    if data ~= nil then\r\n        if isFormData then\r\n            options.data = ''\r\n            for key, value in pairs(data) do\r\n                if string.len(options.data) > 0 then \r\n                    options.data = options.data .. '&'\r\n                end\r\n                options.data = options.data .. key .. '=' .. value\r\n            end\r\n        else\r\n            options.data = json.encode(data)\r\n        end\r\n    end\r\n    return {\r\n        options = options,\r\n        success = success,\r\n        error = error\r\n    }\r\nend"},{"name":"Globals","isMain":false,"isOpen":false,"content":"--[[\r\nGlobal variables handler\r\n@author ikubicki\r\n\r\nMIT License\r\n\r\nCopyright (c) 2020 Irek Kubicki\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n]]\r\n\r\nclass 'Globals'\r\n\r\nfunction Globals:get(name, alternative)\r\n    local response = api.get('/globalVariables/' .. name)\r\n    if response then\r\n        local char = string.sub(response.value, 1, 1)\r\n        if char == '{' or char == '\"' then\r\n            return json.decode(response.value)\r\n        end\r\n        return response.value\r\n    end\r\n    return alternative\r\nend\r\n\r\nfunction Globals:set(name, value)\r\n    local response = api.put('/globalVariables/' .. name, {\r\n        name = name,\r\n        value = json.encode(value)\r\n    })\r\n    if not response then\r\n        response = api.post('/globalVariables', {\r\n            name = name,\r\n            value = json.encode(value)\r\n        })\r\n        \r\n    end\r\n    if response ~= nil then\r\n        if response.type == 'ERROR' then\r\n            QuickApp:error('GLOBALS ERROR[' .. response.reason .. ']:', response.message)\r\n        end\r\n    end\r\nend"},{"name":"Auth","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n]]\r\n\r\nclass 'Auth'\r\n\r\nfunction Auth:new(config)\r\n    self.config = config\r\n    self:init()\r\n    return self\r\nend\r\n\r\nfunction Auth:getHeaders(headers)\r\n    local apiKey = self.config:getApiKey()\r\n    if string.len(apiKey) > 0 then headers[\"x-windy-key\"] = apiKey end\r\n    return headers\r\nend\r\n \r\nfunction Auth:init()\r\n\r\nend"},{"name":"Installation","isMain":false,"isOpen":false,"content":"--[[\r\n   Copyright [2021] [Julien Wetzel]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n\r\n\r\ncode 200    : Ok\r\ncode 300    : Null value (To configure)\r\ncode 303    : Bad value\r\nother code  : No working\r\n\r\n]]\r\n\r\nclass 'Installation'\r\n\r\nfunction Installation:new()\r\n\treturn self\r\nend\r\n\r\nfunction font(v,o) if o == nil then o = \"\" end return \"<font \" .. o .. \">\" .. v .. \"</font>\"end\r\nfunction table(v,o) if o == nil then o = \"\" end return \"<table \" .. o .. \">\" .. v .. \"</table>\" end\r\nfunction tr(v,o) if o == nil then o = \"\" end return \"<tr \" .. o .. \">\" .. v .. \"</tr>\" end\r\nfunction td(v,o) if o == nil then o = \"\" end return \"<td \" .. o .. \">\" .. v .. \"</td>\" end\r\nfunction u(v) return \"<u>\" .. v .. \"</u>\" end\r\nfunction mark(v) return \"<mark>\" .. v .. \"</mark>\" end\r\n\r\nfunction Installation:run(varInfo,nextFunction)\r\n\t--printTable(v)\r\n\tlocal l, txt = \"\", \"\"\r\n\r\n\tfunction stxt(v) txt = txt .. v end\r\n\r\n\tfunction code200(c) \r\n\t\tfor _,v in pairs(c) do if v.code ~= 200 then return false end end\r\n\t\treturn true\r\n\tend\r\n\r\n\tif not(code200(varInfo)) then\r\n\r\n\t\tfunction tableVar(var,status,unit,ex)\r\n\t\t\tlocal col = td(font(var,\"face='Courier New'\"))\r\n\t\t\tcol = col .. td(font(status,\"face='Courier New'\"),\"align=center\")\r\n\t\t\tcol = col .. td(font(unit,\"face='Courier New'\"),\"align=center\")\r\n\t\t\tcol = col .. td(font(ex,\"face='Courier New'\"),\"align=left\")\r\n\t\t\treturn  tr(col)\r\n\t\tend\r\n\r\n\t\t-- Variables Infos\r\n\t\tl = tableVar(\"Variable\",\"Status\",\"Unit\",\"Example\")\r\n\t\tfor k,v in pairs(varInfo) do l = l .. (tableVar(k,self:varStatus(v.code),v.unit,v.example)) end\r\n\t\tstxt(table(l,\"cellpadding='2px' bgcolor=DarkSlateGray border='1' width=480px\"))\r\n\telse\r\n\t\tnextFunction()\r\n\t\treturn\r\n\tend\r\n\r\n\t-- Text content\r\n\tfor k,v in pairs(varInfo) do \r\n\t\tif v.code ~= 200 then \r\n\t\t\tl = tr(td(font(k,\"color=Gainsboro face='Trebuchet MS' size=+1\"),\"colspan='2'\"))\r\n\t\t\tl = l .. tr(td(\"\",\"width='20px'\") .. td(font(v.txt,\"color=Gainsboro face='Trebuchet MS'\")))\r\n\t\t\tstxt(\"<br>\" .. table(l, \"border=0 cellpadding=2\"))\r\n\t\tend \r\n\tend\r\n\r\n\tQuickApp:trace(table(tr(td(txt .. \"<br>\")),\"border=1 bgcolor=#121f1f width=480px\"))\r\nend\r\n\r\nfunction Installation:varStatus(v)\r\n\tif v == 300 then return font(\"to configure\",\"color=OrangeRed\")\r\n\telseif v == 303 then return font(\"bad value\",\"color=Red\")\r\n\telseif v == 200 then return font(\"Configured\",\"color=LawnGreen\")\r\n\telse return font(\"No working\",\"color=red\")\r\n\tend\r\nend"}]}